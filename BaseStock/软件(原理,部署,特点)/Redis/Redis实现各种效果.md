Redis如何实现队列和栈效果?
	lpush从向左推数据lpop从左取数据同理rpush和rpop
	使用lplush存入然后rpop取出就实现了队列的先进先出
	同理lpush加lpop就实现了栈的先进后出

Redis分布式锁它是什么回事？
	1. 使用setNX实现分布式锁
		1.先拿setnx来争抢锁，抢到之后，再用expire给锁加一个过期时间防止锁忘记了释放。
		2.如果在setnx之后执行expire之前进程意外crash或者要重启维护了，那会怎么样？
		set指令有非常复杂的参数，可以同时把setnx和expire合成一条指令来用的！
	2. 基于 Lua 脚本：
		使用 Lua 脚本可以将获取锁和释放锁的操作封装为一个原子操作，避免了多个 Redis 命令之间的竞争条件。
	3. 基于 Redlock 算法：
		Redlock 算法是一种分布式锁算法，可以在多个 Redis 节点之间实现分布式锁。具体来说，Redlock 算法将锁分为多个副本，每个副本在不同的 Redis 节点上，获取锁时需要在多个副本上都获取成功才算获取锁成功。

假如Redis里面有1亿个key，其中有10w个key是以某个固定的已知的前缀开头的，如果将它们全部找出来？
	1.使用keys指令可以扫出指定模式的key列表。
	
如果这个redis正在给线上的业务提供服务，那使用keys指令会有什么问题？
	redis的单线程的。keys指令会导致线程阻塞一段时间，线上服务会停顿，直到指令执行完毕，服务才能恢复。这个时候可以使用scan指令，scan指令可以无阻塞的提取出指定模式的key列表，但是会有一定的重复概率，在客户端做一次去重就可以了，但是整体所花费的时间会比直接用keys指令长。

使用过Redis做异步队列么，你是怎么用的？
	一般使用list结构作为队列，rpush生产消息，lpop消费消息。当lpop没有消息的时候，要适当sleep一会再重试。

可不可以不用sleep呢？
	list还有个指令叫blpop，在没有消息的时候，它会阻塞住直到消息到来。

能不能生产一次消费多次呢？
	使用pub/sub主题订阅者模式，可以实现1:N的消息队列。

pub/sub有什么缺点？
	在消费者下线的情况下，生产的消息会丢失，得使用专业的消息队列如rabbitmq等。

redis如何实现延时队列？
	使用sortedset，拿时间戳作为score，消息内容作为key调用zadd来生产消息，消费者用zrangebyscore指令获取N秒之前的数据轮询进行处理。
	如果有大量的key需要设置同一时间过期，一般需要注意什么？
	如果大量的key过期时间设置的过于集中，到过期的那个时间点，redis可能会出现短暂的卡顿现象。一般需要在时间上加一个随机值，使得过期时间分散一些。

如果再问aof文件过大恢复时间过长怎么办？
	Redis会定期做aof重写，压缩aof文件日志大小。，Redis4.0之后有了混合持久化的功能，将bgsave的全量和aof的增量做了融合处理，这样既保证了恢复的效率又兼顾了数据的安全性。
	如果不要求性能，在每条写指令时都sync一下磁盘，就不会丢失数据。但是在高性能的要求下每次都sync是不现实的，一般都使用定时sync，比如1s1次，这个时候最多就会丢失1s的数据。

Pipeline有什么好处，为什么要用pipeline？
	可以将多次IO往返的时间缩减为一次，前提是pipeline执行的指令之间没有因果相关性。使用redis-benchmark进行压测的时候可以发现影响redis的QPS峰值的一个重要因素是pipeline批次指令的数目。

**类加载器的概述**
	负责加载Java 类的字节码（ .class 文件）到JVM 中（在内存中生成一个代表该类的 Class 对象）。这个过程包括，读取字节数组、验证、解析、初始化等。另外，它也可以加载资源，包括图像文件和配置文件。
		**类的加载概述**
		JVM 启动的时候，并不会一次性加载所有的类，而是根据需要去动态加载,如果该类还未被加载到内存中，则系统会通过**加载，连接，初始化**三步来实现对这个类进行初始化。
		已经被加载的类会直接返回
		1. 加载就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。//class也就是运行时对象
		2. 连接
		3. 验证 是否有正确的内部结构，并和其他类协调一致
		4. 准备 负责为类的静态成员分配内存，并设置默认初始化值
		5. 解析 将类的二进制数据中的符号引用替换为直接引用
		6. 初始化 就是对变量的初始化
		**加载时机**
		1. 创建类对象的实例
		2. 访问类的静态变量，或者为静态变量赋值
		3. 调用类的静态方法
		4. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
		5. Class.forName("com.mysql.jdbc.Driver");创建了Driver类的运行时对象
		6. 初始化某个类的子类
		7. 直接使用java.exe命令来运行某个主类
**类加载器的分类**
	从父类到子类排序	
	1. Bootstrap ClassLoader 根类加载器
	1. Extension ClassLoader 扩展类加载器
	2. AppClass ClassLoader 应用类加载器
	4.自定义类加载器
		除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。如果我们要自定义自己的类加载器，很明显需要继承 `ClassLoader`抽象类。
	**作用:**
	1. Bootstrap ClassLoader 根类加载器(也被称为引导类加载器)
	最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ %JAVA_HOME%/lib目录下的 `rt.jar` 、`resources.jar` 、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
	2. Extension ClassLoader 扩展类加载器
	(主要负责加载 %JRE_HOME%/lib/ext目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。)
	3. AppClass ClassLoader 系统类加载器
	(面向用户的加载器,负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径)
**双亲委派模型原理**
	是Java虚拟机中的一种类加载机制，当Java程序需要加载某个类时，虚拟机会首先委托该任务给父类加载器，如果父类加载器无法完成加载任务，才会由子类加载器来完成。
	(如果子类加载器也无法完成加载任务，那么Java程序会尝试使用自定义类加载器来加载该类。如果所有的加载器都无法完成加载任务，ClassNotFoundException异常)
**作用:**
	它可以避免重复加载已经加载过的类，从而节省内存空间。同时，它也可以防止恶意代码通过自定义类加载器来加载恶意类，从而保证Java程序的安全性。
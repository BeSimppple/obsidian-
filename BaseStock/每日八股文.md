[github完整版](https://github.com/CoderLeixiaoshuai/java-eight-part)
1.一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？
	可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。
2.Java有没有goto?
	没有,但作为保留的关键字存在
3.说说&和&&的区别
	都是与的逻辑运算符, &还可以做位与运算符(两侧均为1时结果为1)
	&需要两侧都进行运算都为true表示成功,&&有短路功能(只要左侧先进行运算如果不通过则不进行下一步运算)
4.在JAVA中如何跳出当前的多重嵌套循环？
	正常情况下break只能跳出当前一层的循环,
	1.在外层设置标号(:outer)然后内部使用带标号的break关键字
	2.使外界结果与内部循环结果绑定(例如外部终止条件设置为一个boolean为true,当内部循环找到对应数时返修改boolean变量位true并break外界自动终止)
5.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?
	在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。
	switch 不支持 long 类型；从 java1.7开始 switch 开始支持 String，这是 Java 的语法糖。
6.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
	java中赋值运算时从左到右的,第一个语句s1从short运算转换成int然后赋值给short会报类型转换错误,第二个语句由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。
7.char型变量中能不能存贮一个中文汉字?为什么?
	可以,因为char的基础编码格式是unicode(包含大部分汉字),如果极其生僻的不包含汉字则不能存储
	ps:  unicode是2个字节而一个汉字占用的也是2个字节,char格式也是占用2个字节
8.用最有效率的方法算出2乘以8等于几?
	2<<3  使用位运算8=2的3次方则将其向左移动3位
9.请设计一个一百亿的计算器
	思路:设计一个自定义类,2个变量int sign;  byte[] val;   sign表示符号,使用字节数组来存储数值的2进制数
	构造方法中将传入的数进行切割分别存入符号和字节数组  
	实现加减成除算法
10.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？
	引用的变量地址不能变,但是引用里变量的对象能被修改
11." = = "和equals方法究竟有什么区别？
	例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量
	= =是对两个参数的堆中的引用地址进行对比是否一致(是否指向相同实际内存地址),其中基础数据类型使用= =
	不同的equals()方法判断模式不同,主要是对内容进行比对,大部分也包含先对地址进行对比
	可以重写equals()方法对引用地址和内容进行比对,默认没有重写equals()方法的类会引用超类Object类的equal方法其中使用的事 = =
12.静态变量和实例变量的区别？
	**静态变量**是属于全局变量不属于一个类,只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间
	**实例变量**是属于某个实例的在实例创建时生成
	**总结:** 实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。
13.是否可以从一个static方法内部发出对非static方法的调用？
	不可以,static方法可以直接类名.方法调用他不需要类的实例创建,因此static方法调用非static无法生成
14.Integer与int的区别
	integer是int的包装类,所以integer是对象默认为null,int默认为0
15.Math.round(11.5)等于多少? Math.round(-11.5)等于多少?
	java中Math类四舍五入的方式是+0.5然后向下取整数
16.请说出作用域public，private，protected，以及不写时的区别
	public全部都可以访问,protected则不同包(非子类)不可访问,默认则非同包都不可访问,private则只允许当前类(自己和内部类)访问
17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?
	重写是传入参数一致且返回参数相同(子类重写父类方法所抛出的异常不能超过父类的范畴)将方法内容进行修改覆盖
	重载则是参数的数量不同或数量相同而类型和次序不同的与原方法不冲突的"两个方法"类似if-else关系
18.构造器Constructor是否可被override?
	构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。
19.接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？
	接口可以继承接口,  抽象类可以实现接口(因为抽象类中可以有具体实现和抽象)   
	抽象类可继承具体类   抽象类可以有静态main方法
20.写clone()方法时，通常都有一行代码，是什么？
	super.clone();
	因为首先要把父类中的成员复制到位，然后才是复制自己的成员
21.面向对象的特征有哪些方面
	**封装**:将固定的逻辑封装成方法或类(目的是实现高内聚,低耦合)
	**多态**:程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定(目的是增强扩展性,方便后期修改)
	**继承**:将原类的基础上进行多样化修改(目的是增强复用性)
	**抽象**:将需要实际情况实际定义的内容进行抽象定义交给子类去具象化(目的是专注当前内容抽象未知内容)
22.java中实现多态的机制是什么？
	靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。
23.abstract class和interface有什么区别?
	抽象类可以有具体实现,普通成员变量和main方法和构造方法和静态方法,成员变量
	接口中所有方法均为public abstract
	接口中不能有静态方法只能有静态成员变量且只能是public static final类型
	接口可以多继承,抽象类只能单继承
24.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?
	**不可以是static**(因为abstract是要被子类实现的但是static没有子类,且static需要划分空间,而abstract无法划分空间)   
	**不可以是native** (native方法表示该方法要用另外一种依赖平台的编程语言(C)实现的，不存在着被子类实现的问题，所以，它也不能是抽象的)
	**不可以是synchronized**(因为没有方法体进行同步)
25.什么是内部类？Static Nested Class 和 Inner Class的不同。
	.一个内部类的对象能够内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中,包括私有数据。 2. 对于同一个包中的其他类来说，内部类能够隐藏起来。 3.匿名内部类可以很方便的定义回调。
	**内部类分类主要有:** 非静态内部类,  静态内部类,   匿名内部类
	1.非静态内部类是最普通的内部类,在非静态内部类上加static即为静态内部类,从狭义上讲他已经算是普通的静态类了具有其他静态类的特性不需要通过外部类实例来创建
	2.匿名内部类和非静态内部类的区别在于匿名内部类是使用时直接定义的一个类用完即销货且没有名字和构造函数
26.内部类可以引用它的包含类的成员吗？有没有什么限制？
	可以,除了静态内部类(基本属于独立的静态类只能访问静态成员)
27.Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?
	可以
29.String是最基本的数据类型吗?
	不是
	String类被final定义不能修改但是不是8大基础类型
30.String s = "Hello";s = s + " world!";这两行代码执行后，原始的String对象中的内容到底变了没有？
	没有,而是重新生成了一个新的s地址  
	因为String(因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象)
31.是否可以继承String类?
	不可以,final不可被继承
32.String s = new String("xyz");创建了几个String Object? 二者之间有什么区别？
	2个或一个,一个是变量s指向了xyz的实际地址   ,一个是xyz对象存在在常量区
	一个的情况是已经在前面创建过xyz对象,这次只创建s指向xyz对象
33.String 和StringBuffer的区别
	1.空间利用率不同,String是不可修改的会造成地址浪费
	2.StringBuffer是线程不安全的,StringBuilder是线程安全的
34.如何把一段逗号分割的字符串转换成一个数组?
	使用正则表达式的split()方法切割,然后使用for循环放入新数组中
35.数组有没有length()这个方法? String有没有length()这个方法？
	数组没有length方法,但是有length属性
	String有length()方法
36.下面这条语句一共创建了多少个对象? String s="a"+"b"+"c"+"d";
	1个
	javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。
37.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?
	会
	finally 在return 之后时，先执行finally 后，再执行该return；finally 内含有return 时，直接执行其return 后结束；finally 在return 前，执行完finally 后再执行return
	Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。
39.final, finally, finalize的区别。
	final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承
	finally 是异常处理语句结构的一部分，总是执行(只有虚拟机停止了才不执行System.exit(0))
	finalize 是 Object 类的一个方法
40.运行时异常与一般异常有何异同？
	异常分为运行时异常(不可查)和编译期异常(可查异常)
	运行时异常是运行程序过程中可能出现的非正常情况称作未检查异常。这种异常通常是由于程序逻辑错误或者运行环境问题（如内存溢出）导致的虽然运行时异常不需要在代码中显式处理，但是应该尽可能地避免产生这种异常.
41.error和exception有什么区别?
	error是机器硬件层面出现的问题或内存溢出线程死活等无法自行克服的问题
	exception是运行环境出现的设计问题程序员可以解决
42.Java中的异常处理机制的简单原理和应用。
	在 Java 应用程序中，异常处理机制为：抛出异常，捕捉异常。
        **抛出异常**：当一个方法出现错误引发异常时，方法创建异常对象并交付运行时系统，异常对象中包含了异常类型和异常出现时的程序状态等异常信息。运行时系统负责寻找处置异常的代码并执行。
        **捕获异常**：在方法抛出异常之后，运行时系统将转为寻找合适的异常处理器（exception handler）。潜在的异常处理器是异常发生时依次存留在调用栈中的方法的集合。当异常处理器所能处理的异常类型与方法抛出的异常类型相符时，即为合适 的异常处理器。运行时系统从发生异常的方法开始，依次回查调用栈中的方法，直至找到含有合适异常处理器的方法并执行。当运行时系统遍历调用栈而未找到合适 的异常处理器，则运行时系统终止。同时，意味着Java程序的终止。
43.请写出你最常见到的5个runtime exception。
	NullPointerException - 空指针引用异常
	ClassCastException - 类型强制转换异常。
	IllegalArgumentException - 传递非法参数异常。
	ArithmeticException - 算术运算异常
	ArrayStoreException - 向数组中存放与声明类型不兼容对象异常
	IndexOutOfBoundsException - 下标越界异常
	NegativeArraySizeException - 创建一个大小为负数的数组错误异常
	NumberFormatException - 数字格式异常
	SecurityException - 安全异常
	UnsupportedOperationException - 不支持的操作异常
44.java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
	使用继承Thread类 实现Runnable接口  线程池
	stop()中断线程的时间无法确定且终止时无论线程逻辑是否完整(会造成严重问题),而且stop()方法为了解决资源锁的问题会丢弃所有锁这反而造成了逻辑问题(原子性逻辑问题:一个线程可能会影响其他线程)--如果我们要中线线程需要自行编码,如果使用的是线程池可以使用shutdown()方法用的温和式终止线程
	suspend()使线程进入悬挂状态,但是任然持有悬挂前的资源并且禁止任何访问,会造成死锁问题
45.sleep() 和 wait() 有什么区别?
	sleep()是持有同步资源锁并放弃占用cpu,到期后自动继续执行
	wait()是放弃同步资源锁并放弃占用cpu进入待机状态,可通过notify()来唤醒,唤醒后由于并没有持有同步资源锁所以第一时间不一定能立刻运行,同样到等待队列和其他线程争夺同步资源锁
	sleep()是属于线程类,而wait()属于Object类,所以sleep()在任何情况下可以调用,而wait只有在同步方法,同步块中调用
	sleep()需要捕获或处理异常,wait()并不需要
46.同步和异步有何异同，在什么情况下分别使用他们？举例说明。
	同步指事情逐步完成,异步指事情切块同时进行
	生活例子:
	买菜面对商贩需要一步步排队实现买菜结账过程是同步
	做菜可以热锅烧油的同时进行切菜,洗菜,清理桌面,摆放碗筷等过程为异步
	工程例子:
	银行取账代码需要将取钱数目和账单存款进行绑定顺序执行完成同步事务才能保证安全
	elasticsearch将数据库中的内容通过异步队列异步方式同步到索引库,只需要将消息发出然后收到反馈的确认信息即可而不需要等待实际完成同步加大了效率
47.多线程同步有几种实现方式?  (内容不一定准确和易于理解)
	**同步锁(synchronized)**  **lock和nofify方法**   **Lock方法**
	**互斥锁（mutex）**
	是最常见的线程同步方式，它是一种特殊的变量，它有 _lock_ 和 _unlock_ 两种状态，一旦获取，就会上锁，且只能由该线程解锁，期间，其他线程无法获取
	**条件变量（condition）**
	针对互斥锁浪费资源且效率低的缺点，可以使用条件变量。
	条件变量的方法是，当线程在等待某些满足条件时使线程进入睡眠状态，一旦条件满足，就唤醒，这样不会占用宝贵的互斥对象锁，实现高效
	条件变量允许线程阻塞并等待另一个线程发送信号，一般和互斥锁一起使用。
	**读写锁（reader-writer lock）**
	一般用在读和写的次数有很大不同的场合。即对某些资源的访问会出现两种情况，一种是访问的排他性，需要独占，称之为写操作；还有就是访问可以共享，称之为读操作
	**信号量（semphore）**
48.启动一个线程是用run()还是start()？
	线程有6种状态 
	一、新建状态(NEW)
	二、运行状态(RUNNABLE) 就绪状态（READY) 其他状态->就绪 ...
	三、阻塞状态(BLOCKED)
	四、等待状态(WAITING) 运行->等待 等待->就绪
	五、超时等待状态(TIMED_WAITING) 运行->超时等待 超时等待->就绪
	六、消亡状态
	启动一个线程是调用start()方法，使线程就绪状态，以后可以被调度为运行状态，一个线程必须关联一些具体的执行代码，run()方法是该线程所关联的执行代码。
49.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
	分几种情况
	1.其他方法前是否加了synchronized关键字，如果没加，则能。
	2.如果这个方法内部调用了wait，则可以进入其他synchronized方法。
	3.如果其他个方法都加了synchronized关键字，并且内部没有调用wait，则不能。
	4.如果其他方法是static，它用的同步锁是当前类的字节码，与非静态的方法不能同步，因为非静态的方法用的是this。
50.线程与进程的关系?。
	进程是一条路,线程就是路上的车,cpu就是路上的交警
	进程是一个实体可以创建多条线程,线程也可以创建线程,一条路同一时间只能通过cpu调用一个线程通过快速切换达到同时进行效果
	进程因为是一个实体所以一些变量共享不方便,通常采用线程,同时线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间
51.简述synchronized和java.util.concurrent.locks.Lock的异同 ？
	Lock能实现所有synchronized的作用,且更精确的线程语义和更好的性能。synchronized会自动释放锁，而Lock一定要求程序员手工释放，并且必须在finally从句中释放。Lock还有更强大的功能，例如，它的tryLock方法可以非阻塞方式去拿锁
54.Collection框架中实现比较要实现什么接口
	comparable/comparator接口
55.ArrayList和Vector的区别
	ArrayList是线程不安全的数组+链表结构的有序集合
	Vector是线程安全的
	Vector有主动扩容的方法
	还有细微的差别是ArrayList默认扩容是1.5倍 Vector是2倍
56.HashMap和Hashtable的区别
	HashMap是线程不安全的键值对形式的Map 通过Hash对键进行去重 允许Null作为间值
	HashTable是线程安全的且不允许Null值作为键值
57.List 和 Map 区别?
	List是存储单列数据的集合且是有序的允许重复,Map是双列数据键值不允许重复
58.List, Set, Map是否继承自Collection接口,三个接口，存取元素时，各有什么特点?
	List和Set是,Map不是
	List可重复,有序   Set去重,无序(hashcode排序)  Map双列,键值去重,无序
59.数组,链表,二叉树,红黑树的插入和搜索性能排序?
	**数组** :
	优点:内存空间占用少且为连续区域,数组内数据有地址有序,因此可以随机访问,查询效率高
	缺点:大小固定,不适合动态存储,不方便动态添加删除(会导致大量元素一起移动)
	**链表**:
	优点:方便插入和删除(只需要改变必要更改前后一个节点信息就够了,不需要改变内存地址),扩展性稍好
	缺点:只能通过顺次指针访问大量数据效率低
	
60.说出ArrayList,Vector, LinkedList的存储性能和特性
61.去掉一个Vector集合中重复的元素
62.Collection 和 Collections的区别。
63.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用= =还是equals()? 它们有何区别?
64.你所知道的集合类都有哪些？主要方法？
65.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?
66.TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！
67.说出一些常用的类，包，接口，请各举5个。
68.java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？
69.字节流与字符流的区别
70.什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。
71.描述一下JVM加载class文件的原理机制?
72.heap和stack有什么区别。
73.GC是什么? 为什么要有GC?
74.垃圾回收的优点和原理。并考虑2种回收机制。
75.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
76.什么时候用assert。
77.java中会存在内存泄漏吗，请简单描述。
78.能不能自己写个类，也叫java.lang.String？
79.获得一个类的类对象有哪些方式？
80.Java代码查错
81:为什么推荐使用Map map = new HashMap() 而不是 HashMap map = new HashMap() ？
	Map map = new HashMap();
	Map是一个接口，HashMap是具体的实现类。
	由于接口是类的蓝图，是一个抽象的概念，不能被实例化，因此接口需要由具体的类来实现。
	这条代码指明：由HashMap类来实现接口Map中描述的方法。
	HashMap map = new HashMap();
	声明一个HashMap类型的map，由HashMap类实现。
	为什么更推荐第一种用接口的声明方式？
	这个问题等同于为什么要在编程中使用接口，而不是直接使用实现类。其实这就是面对对象编程（OOP）的思想精髓。简单来说就是：上层接口描述的功能不变，下层的具体实现可以不断修改替换。上层的调用者只用知道map的功能，不必关心map的具体实现。
	例如，某天开发人员开发出一个各方面性能都优于HashMap的SuperMap类，则map可以直接改成由SuperMap来实现：Map map = new SuperMap()。对于外部调用者来说，使用的还是那个map，殊不知底层实现的升级已经让他们用上了优化版的map。如果一开始就定义map为HasMap类型，无法做出这样的优化，很明显 HashMap map = new SuperMap() 是条错误的代码。这就是使用接口声明的好处，增加系统灵活性，隔离性等。
**不太好的题目**
28.super.getClass()方法调用
	getClass()方法在Object类是被定义为final所以不能被继承,super.getClass()等同于this.getClass()


**练习题**
52.设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。
53.子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。











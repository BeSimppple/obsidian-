[github完整版](https://github.com/CoderLeixiaoshuai/java-eight-part)
1.一个".java"源文件中是否可以包括多个类（不是内部类）？有什么限制？
	可以有多个类，但只能有一个public的类，并且public的类名必须与文件名相一致。
2.Java有没有goto?
	没有,但作为保留的关键字存在
3.说说&和&&的区别
	都是与的逻辑运算符, &还可以做位与运算符(两侧均为1时结果为1)
	&需要两侧都进行运算都为true表示成功,&&有短路功能(只要左侧先进行运算如果不通过则不进行下一步运算)
4.在JAVA中如何跳出当前的多重嵌套循环？
	正常情况下break只能跳出当前一层的循环,
	1.在外层设置标号(:outer)然后内部使用带标号的break关键字
	2.使外界结果与内部循环结果绑定(例如外部终止条件设置为一个boolean为true,当内部循环找到对应数时返修改boolean变量位true并break外界自动终止)
5.switch语句能否作用在byte上，能否作用在long上，能否作用在String上?
	在switch（expr1）中，expr1只能是一个整数表达式或者枚举常量（更大字体），整数表达式可以是int基本类型或Integer包装类型，由于，byte,short,char都可以隐含转换为int，所以，这些类型以及这些类型的包装类型也是可以的。
	switch 不支持 long 类型；从 java1.7开始 switch 开始支持 String，这是 Java 的语法糖。
6.short s1 = 1; s1 = s1 + 1;有什么错? short s1 = 1; s1 += 1;有什么错?
	java中赋值运算时从左到右的,第一个语句s1从short运算转换成int然后赋值给short会报类型转换错误,第二个语句由于 += 是java语言规定的运算符，java编译器会对它进行特殊处理，因此可以正确编译。
7.char型变量中能不能存贮一个中文汉字?为什么?
	可以,因为char的基础编码格式是unicode(包含大部分汉字),如果极其生僻的不包含汉字则不能存储
	ps:  unicode是2个字节而一个汉字占用的也是2个字节,char格式也是占用2个字节
8.用最有效率的方法算出2乘以8等于几?
	2<<3  使用位运算8=2的3次方则将其向左移动3位
9.请设计一个一百亿的计算器
	思路:设计一个自定义类,2个变量int sign;  byte[] val;   sign表示符号,使用字节数组来存储数值的2进制数
	构造方法中将传入的数进行切割分别存入符号和字节数组  
	实现加减成除算法
10.使用final关键字修饰一个变量时，是引用不能变，还是引用的对象不能变？
	引用的变量地址不能变,但是引用里变量的对象能被修改
11." = = "和equals方法究竟有什么区别？
	例如Objet obj = new Object();变量obj是一个内存，new Object()是另一个内存，此时，变量obj所对应的内存中存储的数值就是对象占用的那块内存的首地址。对于指向对象类型的变量
	= =是对两个参数的堆中的引用地址进行对比是否一致(是否指向相同实际内存地址),其中基础数据类型使用= =
	不同的equals()方法判断模式不同,主要是对内容进行比对,大部分也包含先对地址进行对比
	可以重写equals()方法对引用地址和内容进行比对,默认没有重写equals()方法的类会引用超类Object类的equal方法其中使用的事 = =
12.静态变量和实例变量的区别？
	**静态变量**是属于全局变量不属于一个类,只要程序加载了类的字节码，不用创建任何实例对象，静态变量就会被分配空间
	**实例变量**是属于某个实例的在实例创建时生成
	**总结:** 实例变量必须创建对象后才可以通过这个对象来使用，静态变量则可以直接使用类名来引用。
13.是否可以从一个static方法内部发出对非static方法的调用？
	不可以,static方法可以直接类名.方法调用他不需要类的实例创建,因此static方法调用非static无法生成
14.Integer与int的区别
	integer是int的包装类,所以integer是对象默认为null,int默认为0
15.Math.round(11.5)等于多少? Math.round(-11.5)等于多少?
	java中Math类四舍五入的方式是+0.5然后向下取整数
16.请说出作用域public，private，protected，以及不写时的区别
	public全部都可以访问,protected则不同包(非子类)不可访问,默认则非同包都不可访问,private则只允许当前类(自己和内部类)访问
17.Overload和Override的区别。Overloaded的方法是否可以改变返回值的类型?
	重写是传入参数一致且返回参数相同(子类重写父类方法所抛出的异常不能超过父类的范畴)将方法内容进行修改覆盖
	重载则是参数的数量不同或数量相同而类型和次序不同的与原方法不冲突的"两个方法"类似if-else关系
18.构造器Constructor是否可被override?
	构造器Constructor不能被继承，因此不能重写Override，但可以被重载Overload。
19.接口是否可继承接口? 抽象类是否可实现(implements)接口? 抽象类是否可继承具体类(concrete class)? 抽象类中是否可以有静态的main方法？
	接口可以继承接口,  抽象类可以实现接口(因为抽象类中可以有具体实现和抽象)   
	抽象类可继承具体类   抽象类可以有静态main方法
20.写clone()方法时，通常都有一行代码，是什么？
	super.clone();
	因为首先要把父类中的成员复制到位，然后才是复制自己的成员
21.面向对象的特征有哪些方面
	**封装**:将固定的逻辑封装成方法或类(目的是实现高内聚,低耦合)
	**多态**:程序中定义的引用变量所指向的具体类型和通过该引用变量发出的方法调用在编程时并不确定，而是在程序运行期间才确定(目的是增强扩展性,方便后期修改)
	**继承**:将原类的基础上进行多样化修改(目的是增强复用性)
	**抽象**:将需要实际情况实际定义的内容进行抽象定义交给子类去具象化(目的是专注当前内容抽象未知内容)
22.java中实现多态的机制是什么？
	靠的是父类或接口定义的引用变量可以指向子类或具体实现类的实例对象，而程序调用的方法在运行期才动态绑定，就是引用变量所指向的具体实例对象的方法，也就是内存里正在运行的那个对象的方法，而不是引用变量的类型中定义的方法。
23.abstract class和interface有什么区别?
	抽象类可以有具体实现,普通成员变量和main方法和构造方法和静态方法,成员变量
	接口中所有方法均为public abstract
	接口中不能有静态方法只能有静态成员变量且只能是public static final类型
	接口可以多继承,抽象类只能单继承
24.abstract的method是否可同时是static,是否可同时是native，是否可同时是synchronized?
	**不可以是static**(因为abstract是要被子类实现的但是static没有子类,且static需要划分空间,而abstract无法划分空间)   
	**不可以是native** (native方法表示该方法要用另外一种依赖平台的编程语言(C)实现的，不存在着被子类实现的问题，所以，它也不能是抽象的)
	**不可以是synchronized**(因为没有方法体进行同步)
25.什么是内部类？Static Nested Class 和 Inner Class的不同。
	.一个内部类的对象能够内部类可以直接访问外部类中的成员变量，内部类可以定义在外部类的方法外面，也可以定义在外部类的方法体中,包括私有数据。 2. 对于同一个包中的其他类来说，内部类能够隐藏起来。 3.匿名内部类可以很方便的定义回调。
	**内部类分类主要有:** 非静态内部类,  静态内部类,   匿名内部类
	1.非静态内部类是最普通的内部类,在非静态内部类上加static即为静态内部类,从狭义上讲他已经算是普通的静态类了具有其他静态类的特性不需要通过外部类实例来创建
	2.匿名内部类和非静态内部类的区别在于匿名内部类是使用时直接定义的一个类用完即销货且没有名字和构造函数
26.内部类可以引用它的包含类的成员吗？有没有什么限制？
	可以,除了静态内部类(基本属于独立的静态类只能访问静态成员)
27.Anonymous Inner Class (匿名内部类) 是否可以extends(继承)其它类，是否可以implements(实现)interface(接口)?
	可以
29.String是最基本的数据类型吗?
	不是
	String类被final定义不能修改但是不是8大基础类型
30.String s = "Hello";s = s + " world!";这两行代码执行后，原始的String对象中的内容到底变了没有？
	没有,而是重新生成了一个新的s地址  
	因为String(因为String被设计成不可变(immutable)类，所以它的所有对象都是不可变对象)
31.是否可以继承String类?
	不可以,final不可被继承
32.String s = new String("xyz");创建了几个String Object? 二者之间有什么区别？
	2个或一个,一个是变量s指向了xyz的实际地址   ,一个是xyz对象存在在常量区
	一个的情况是已经在前面创建过xyz对象,这次只创建s指向xyz对象
33.String 和StringBuffer的区别
	1.空间利用率不同,String是不可修改的会造成地址浪费
	2.StringBuffer是线程不安全的,StringBuilder是线程安全的
34.如何把一段逗号分割的字符串转换成一个数组?
	使用正则表达式的split()方法切割,然后使用for循环放入新数组中
35.数组有没有length()这个方法? String有没有length()这个方法？
	数组没有length方法,但是有length属性
	String有length()方法
36.下面这条语句一共创建了多少个对象? String s="a"+"b"+"c"+"d";
	1个
	javac编译可以对字符串常量直接相加的表达式进行优化，不必要等到运行期去进行加法运算处理，而是在编译时去掉其中的加号，直接将其编译成一个这些常量相连的结果。
37.try {}里有一个return语句，那么紧跟在这个try后的finally {}里的code会不会被执行，什么时候被执行，在return前还是后?
	会
	finally 在return 之后时，先执行finally 后，再执行该return；finally 内含有return 时，直接执行其return 后结束；finally 在return 前，执行完finally 后再执行return
	Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。
39.final, finally, finalize的区别。
	final 用于声明属性，方法和类，分别表示属性不可变，方法不可覆盖，类不可继承
	finally 是异常处理语句结构的一部分，总是执行(只有虚拟机停止了才不执行System.exit(0))
	finalize 是 Object 类的一个方法
40.运行时异常与一般异常有何异同？
	异常分为运行时异常(不可查)和编译期异常(可查异常)
	运行时异常是运行程序过程中可能出现的非正常情况称作未检查异常。这种异常通常是由于程序逻辑错误或者运行环境问题（如内存溢出）导致的虽然运行时异常不需要在代码中显式处理，但是应该尽可能地避免产生这种异常.
41.error和exception有什么区别?
	error是机器硬件层面出现的问题或内存溢出线程死活等无法自行克服的问题
	exception是运行环境出现的设计问题程序员可以解决
42.Java中的异常处理机制的简单原理和应用。
	
43.请写出你最常见到的5个runtime exception。
	
44.java中有几种方法可以实现一个线程？用什么关键字修饰同步方法? stop()和suspend()方法为何不推荐使用？
45.sleep() 和 wait() 有什么区别?
46.同步和异步有何异同，在什么情况下分别使用他们？举例说明。
47.多线程有几种实现方法?同步有几种实现方法?
48.启动一个线程是用run()还是start()？
49.当一个线程进入一个对象的一个synchronized方法后，其它线程是否可进入此对象的其它方法?
50.线程的基本概念、线程的基本状态以及状态之间的关系。
51.简述synchronized和java.util.concurrent.locks.Lock的异同 ？
52.设计4个线程，其中两个线程每次对j增加1，另外两个线程对j每次减少1。写出程序。
53.子线程循环10次，接着主线程循环100，接着又回到子线程循环10次，接着再回到主线程又循环100，如此循环50次，请写出程序。
54.Collection框架中实现比较要实现什么接口
55.ArrayList和Vector的区别
56.HashMap和Hashtable的区别
57.List 和 Map 区别?
58.List, Set, Map是否继承自Collection接口?
59.List、Map、Set三个接口，存取元素时，各有什么特点？
60.说出ArrayList,Vector, LinkedList的存储性能和特性
61.去掉一个Vector集合中重复的元素
62.Collection 和 Collections的区别。
63.Set里的元素是不能重复的，那么用什么方法来区分重复与否呢? 是用= =还是equals()? 它们有何区别?
64.你所知道的集合类都有哪些？主要方法？
65.两个对象值相同(x.equals(y) == true)，但却可有不同的hash code，这句话对不对?
66.TreeSet里面放对象，如果同时放入了父类和子类的实例对象，那比较时使用的是父类的compareTo方法，还是使用的子类的compareTo方法，还是抛异常！
67.说出一些常用的类，包，接口，请各举5个。
68.java中有几种类型的流？JDK为每种类型的流提供了一些抽象类以供继承，请说出他们分别是哪些类？
69.字节流与字符流的区别
70.什么是java序列化，如何实现java序列化？或者请解释Serializable接口的作用。
71.描述一下JVM加载class文件的原理机制?
72.heap和stack有什么区别。
73.GC是什么? 为什么要有GC?
74.垃圾回收的优点和原理。并考虑2种回收机制。
75.垃圾回收器的基本原理是什么？垃圾回收器可以马上回收内存吗？有什么办法主动通知虚拟机进行垃圾回收？
76.什么时候用assert。
77.java中会存在内存泄漏吗，请简单描述。
78.能不能自己写个类，也叫java.lang.String？
79.获得一个类的类对象有哪些方式？
80.Java代码查错
81:为什么推荐使用Map map = new HashMap() 而不是 HashMap map = new HashMap() ？
	Map map = new HashMap();
	Map是一个接口，HashMap是具体的实现类。
	由于接口是类的蓝图，是一个抽象的概念，不能被实例化，因此接口需要由具体的类来实现。
	这条代码指明：由HashMap类来实现接口Map中描述的方法。
	HashMap map = new HashMap();
	声明一个HashMap类型的map，由HashMap类实现。
	为什么更推荐第一种用接口的声明方式？
	这个问题等同于为什么要在编程中使用接口，而不是直接使用实现类。其实这就是面对对象编程（OOP）的思想精髓。简单来说就是：上层接口描述的功能不变，下层的具体实现可以不断修改替换。上层的调用者只用知道map的功能，不必关心map的具体实现。
	例如，某天开发人员开发出一个各方面性能都优于HashMap的SuperMap类，则map可以直接改成由SuperMap来实现：Map map = new SuperMap()。对于外部调用者来说，使用的还是那个map，殊不知底层实现的升级已经让他们用上了优化版的map。如果一开始就定义map为HasMap类型，无法做出这样的优化，很明显 HashMap map = new SuperMap() 是条错误的代码。这就是使用接口声明的好处，增加系统灵活性，隔离性等。
**不太好的题目**
28.super.getClass()方法调用
	getClass()方法在Object类是被定义为final所以不能被继承,super.getClass()等同于this.getClass()

==ip地址==:
你在网络上的地址
==mask子网掩码==:
是32位二进制数与ip地址结合使用主要是255.255.255.0
主要作用是屏蔽ip地址的一部分以区分网络标识和主机标识,并说明实在广域网还是局域网中
二是将大的ip网络划分为若干小的子网络减少ip浪费
使用是将ip每段与子网掩码每段相乘255=11111相乘等于原数,0=00000相乘等于0
==route==:
狭义上就是路由器,实现本地网络的分流作用
==dns域名解析服务器==:
ip与dns结合形成网络中的域名
每个网址有对应的域名,会先从本地找host配置的域名映射是否有ip然后再去从远程dns服务器中找对应ip

LAN: Local Area Network_


---
mac地址:网卡硬件的全世界唯一识别码

就是用来实现网络互连的不同计算机上运行的程序间可以进行数据交换。
从客户端发送请求到服务端,
可以把浏览器当做客户端输入网址就是ip地址和端口,然后在idea中写好服务端接收到请求头再写入输出到网页上

网络编程三要素

ip地址.

设备在网络中的唯一表示

拥有唯一性

有ipv4类型地址由四个字节组成 4个0-255

例如:192.168.11.42 可以通过DOS输入ipconfig确定本机ip

ipv6地址 由八组每个4个16进制

例如:1a2b:0000:aaaa:0000:0000:0000:aabb:1f2f

回路地址:127.0.0.1自己和自己通话

255.255.255.255广播地址,用于广播

端口号:

拥有唯一性

端口号范围由0-65535之间,每个网络程序对应绑定一个端口号,传输数据即确定机器ip地址后还要明确发到哪个程序

1024以下基本都被系统程序占用

常用端口

mysql: 3306

  

oracle: 1521

web: 80

tomcat: 8080

  

协议:

通信协议是对计算机必须遵守的规则，只有遵守这些规则，计算机之间才能进行通信.

UDP协议:

面向无连接，数据不安全，速度快。不区分客户端与服务端。

不用确认是否建立链接便开始通信,即无链接通信协议

UDP协议消耗资源小,通信效率搞,偶尔会应用于音频,视频传输,但是会偶尔丢失一两个数据包

qq.飞秋集邮使用UDP协议.也有TCP协议

特点:数据被限制在64KB以内,超出范围不能发送

TCP协议:
面向连接(三次握手),数据安全,速度略低,分为客户端和服务端

三次握手:客户端先向服务端发起请求,服务端响应请求,传输数据

![[网络通信_image_1.jpg|400]]
==OSI网络模型==

![[网络通信_image_2.jpg|400]]

Socket通信原理

Socket套接字概述：

网络上具有唯一标识的IP地址和端口号组合在一起才能构成唯一能识别的标识符套接字。

通信的两端都有Socket。

网络通信其实就是Socket间的通信。

而Socket之间的通信本质上是IO流之间的通信

数据在两个Socket间通过IO流传输。

Socket在应用程序中创建，通过一种绑定机制与驱动程序建立关系，告诉自己所对应的IP和

port。

  

UDP传输

1.发送Send

创建DatagramSocket, 随机端口号

此类用来发送和接受数据报包的套接字

  

创建DatagramPacket, 指定数据, 长度, 地址, 端口

此类表示数据报包

buf - 包数据。

length - 包长度。

address - 目的地址。

port - 目的端口号。

  

使用DatagramSocket发送DatagramPacket

关闭DatagramSocket

关流只需要关闭socket对象就行,因为输入或者输出流都是从Socket中获取的

2.接收Receive

创建DatagramSocket, 指定端口号

创建DatagramPacket, 指定数组, 长度

使用DatagramSocket接收DatagramPacket

从DatagramPacket中获取数据

关闭DatagramSocket

改进------------------------------------------

在初版基础上改进的需求:

1,发送端和接收端功能在一个窗口完成.

2,发送端可以多次发送键盘录入的消息,接收端可以多次接收消息.如果录入的是"quit"那么退

出发送端,接收端根据发送端的"quit"也退出.

3,解决接收端使用字节流接收数据,数据后面有多余空格的BUG.

4,在接收端加入发送者信息的显示(ip+端口)

  

5.创建多线程的线程池完成接收和传输

TCP协议

1.客户端

创建Socket连接服务端(指定ip地址,端口号)通过ip地址找到对应的服务器

调用Socket的getInputStream()和getOutputStream()方法获取和服务端相连的io流

输入流可以读取服务端写入的数据

输出流可以写入数据到服务端的输入流

2.服务端

创建ServerSocket(需要指定端口号)

调用ServerSocket的accept()方法接收一个客户端请求,得到一个Socket

Socket中的accept方法:侦听并获取到Sockt的链接

就是创建一个Socket然后接受,其余都是IO的过程

  

调用Socket的getInputStream()和getOutputStream()方法获取和服务端相连的io流

输入流可以读取客户端写入的数据

输出流可以写入数据到客户端端的输入流

服务器端是没有io流的,它是由accpet方法接收到的客户端提供的Socket对象调用方法来使用io流的

因此每个不同客户端提供的不同的socket对象,所以能11对应

优化------------------

文件名字写死,

如果名字重复则会覆盖第一个文件所以改进

名字用System.CurrentTimeMillis()+".jpg"方式命名

  

服务端循环接收

whle(true){

Socket accept = serverSocket.accept();

......

}无限循环

  

效率问题:

利用多线程技术优化

while（true）{

Socket accept = serverSocket.accept();

// accept 交给子线程处理.

new Thread(() ‐> {

......

InputStream bis = accept.getInputStream();

......

}).start();

}
#语法糖（syntactic_sugar） #语法盐（syntactic_salt）
	**语法糖**是泛指这样的一种语法，它使程序员完成某项功能更容易，缺少它并非会导致该项功能无法实现，但使用它编写出的代码更易懂、更简洁。
	实际是底层将过程进行隐藏了(底层逻辑不变但便于书面理解)
	**语法盐**是泛指这样的一种语法，它可以降低程序员编写出不良代码的概率，但代价是使代码编写更加繁琐。这通常是在容易犯的错误上加上的额外语法限制，从而语法盐也有可能使代码可读性下降或损害代码质量。
#socket(套接字)
	IP 地址和端口号的组合被称为套接字
#反编译
	将EXE程序通过反编译软件生成原代码格式(例如C)
#强类型语言 #弱类型语言
	***强类型***语言是一种强制类型定义的语言，即一旦某一个变量被定义类型，如果不经强制转换，那么它永远就是该数据类型。 
	***弱类型***语言是一种弱类型定义的语言，某一个变量被定义类型，该变量可以根据环境变化自动进行转换，不需要经过现行强制转换
	强类型典型:Java、.net、Python、C++等语言。  弱类型典型:PHP，JavaScript等前端语言
#面向对象 #面向过程
	主要区别:
	**1.抽象的对象不同:** 面向过程的编程思想是以过程为中心，将问题分解为一系列的步骤，然后按照一定的顺序依次执行这些步骤。而面向对象的编程思想则是以对象为中心，将问题分解为一些相互协作的对象，每个对象具有自己的属性和方法，通过消息传递的方式进行交互。
	**2.封装性不同:** 面向过程的编程思想强调的是数据和方法的分离，数据和方法是分开定义的。而面向对象的编程思想则强调的是将数据和方法封装在一起，通过接口来控制对数据的访问。
	**3.是否支持继承:** 面向对象的编程思想支持继承，一个类可以继承另一个类的属性和方法，并可以在此基础上进行扩展和修改。而面向过程的编程思想不支持继承，只能通过复制代码来实现类似的功能。
	**4.是否支持多态:** 面向对象的编程思想支持多态，同一个方法可以有不同的实现方式，具体的实现方式取决于调用该方法的对象。而面向过程的编程思想不支持多态，同一个方法只有一种实现方式。
#包装类 #基础数据类型 #拆箱 #装箱
	有8大基础数据类型按照字节大小分类:
	byte  boolean   (一个字节)  char   short  (两个字节) 
	 int float (四个字节)  long  double (八个字节)
	基础数据类型>装箱>包装类    包装类>拆箱>基础数据类型
	**包装类的作用是:**
	1.编码过程中只接收对象的情况通过将基础数据类型封装成对象形式
	2.方便数据类型之间的转换例如string和int
#重写 #重载
	**重写**是传入参数一致且返回参数相同(子类重写父类方法所抛出的异常不能超过父类的范畴)将方法内容进行修改覆盖
	**重载**则是参数的数量不同或数量相同而类型和次序不同的与原方法不冲突的"两个方法"类似if-else关系
#位运算 #逻辑运算符
	从现代计算机中所有的数据二进制的形式存储在设备中。即 0、1 两种状态，计算机对二进制数据进行的运算(+、-、* 、/)都是叫**位运算**，即将符号位共同参与运算的运算。
	**逻辑运算**则是对逻辑的boolean判断
	位运算是对二进制数的每一位进行操作，逻辑运算是对逻辑值进行操作。
#内存泄漏
	指一个不再被程序使用的对象或变量一直被占据在内存中
#可重入性(REentrant)
	常用在多线程和锁上,
	简介:  若一个程序或子程序可以“在任意时刻被中断然后操作系统调度执行另外一段代码，这段代码又调用了该子程序不会出错”，则称其为可重入（reentrant或re-entrant）的。 即当该子程序正在运行时，执行线程可以再次进入并执行它，仍然获得符合设计时预期的结果
	注意:可重入性的代码根据原理推导其不可能包含(static属性的全局变量,且调用的函数call也必须是可重入的)
#乐观锁 #悲观锁
	定义:认为多线程操作时会有污染产生就是悲观锁,认为没有就是乐观锁
	悲观锁保证线程安全,但是效率低  ,sql中语句后面跟for update即可启动悲观锁
	乐观锁通过CAS(compare and swap)自旋温和的处理
	首先当多个线程同时访问同一个共享资源时，通过自旋等待共享资源的锁定状态，然后使用CAS原子操作来尝试获取锁，如果获取成功则执行操作，如果获取失败则重新尝试。
	主要三个参数:共享变量的内存地址、期望值和新值。如果共享变量的值等于期望值，则使用新值替换共享变量的值。CAS自旋操作是原子的，因此可以保证线程安全。
#公平锁 #非公平锁
	公平锁是按照线程的先来后到顺序分配的
	非公平锁是随机竞争分配的
#反射
	反射是一种机制
	是一种在运行时动态地获取类的信息(通过获取Class对象)然后操作类的方法和属性的机制
	常用获取Class方式 class.forName(类路径)，类.class()，对象的getClass（）
#用户态 #内核态
	用户态和内核态是两种不同的运行级
	**简介**:用户态是指程序运行在较低的权限级别，只能访问受限资源的状态,  内核态是指操作系统运行在较高的权限级别，可以访问系统的所有资源
	因为有些命令(例如清除内存,设置时钟)是会造成系统崩溃的,所以`Intel`的`CPU`将特权级别分为4个级别从ring0-ring3依次降低,
	内核必须提供一组通用的访问接口，这些接口就叫系统调用
	3种方式切换到内核态,1.系统调用 2.发生异常 3.外设中断(当外设完成用户的请求时，会向CPU发送中断信号)
	从用户态到内核态切换会造成资源损耗主要由于以下几个方面:
	1.上下文切换（Context Switching） 需要保存当前进程的上下文信息（如程序计数器、寄存器状态、堆栈指针等），以便在切回用户态时能够恢复执行。同时，内核需要加载新的上下文信息，以便执行内核态的操作
	2.内存访问（Memory Access）需要将进程的虚拟地址转换成物理地址，这个过程需要进行内存访问
	3.安全检查（Security Checks）

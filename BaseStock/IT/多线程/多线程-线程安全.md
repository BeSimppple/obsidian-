线程安全不一定要有synchronized或者lock.可以由代码来完成
**CAS概念**:
	compare and swap 比较和交换
	没有任何阻塞但保证了线程安全
	V:variable要修改的变量
	E:exptected 期望值
	N:new 新值
	就是认准V修改
	而多条线路执行时E可能会被修改这时
	CAS会自旋重新生成对应E的值

什么是自旋？
	很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程
	都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized 里面的代码执行得非常快， 不妨让等待锁的线程不要被阻塞， 而是在synchronized 的边界做忙循环（不放弃cpu而作的空循环），这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。
	如果要修改一个数组中的 1 为 2
	则这个1为期望值:代表如果是1则修改
	则E在的地方称为V
	要修改的值2 为N
**什么是线程隔离**
	多个线程可以同时执行不同的任务或访问共享的资源。线程隔离通过限制线程之间的共享访问，确保每个线程拥有自己的独立资源副本，避免了数据竞争和不确定的行为。
	**作用**:
	用于确保不同的线程在执行过程中相互独立、互不干扰。线程隔离的目的是提供并发执行的安全性和可靠性，确保多线程环境下的数据一致性和可预测性
	**分类**:
		1. **内存隔离**：每个线程拥有独立的内存空间，包括栈和堆。这样可以避免线程之间的内存冲突和竞争条件，每个线程都可以独立地操作自己的数据，不会影响其他线程的执行。
		2. **数据隔离**：线程之间的数据是相互独立的，每个线程拥有自己的数据副本。这可以防止数据共享导致的并发问题，例如数据竞争和死锁。
		3. **状态隔离**：线程之间的执行状态是独立的，一个线程的异常或错误不会影响其他线程的执行。每个线程都有自己的执行路径和错误处理机制，确保程序的健壮性和稳定性。
	**实现方法**:
		1. 使用线程本地存储（Thread-Local Storage，TLS）来存储线程私有数据，
		2. 使用锁机制来保护共享资源的访问，
		3. 使用消息传递等通信机制来实现线程之间的数据交换。
Vector
	特性:可以增加和删除的容量可变的对象数组
	互斥规则
	写-写：互斥，阻塞
	读-写：互斥、阻塞
	读-读：互斥、阻塞
	总结:效率低下,使用和arrayList无区别
CpoyOnWriteArrayList
	arrayList的一个线程安全的变体,其中操作(add.set,等等)都是通过对底层数组进行一次新的复制来实现的
	//读没有不同,就是对原数组的数值进行读取
	//写add,set,...在底层代码的支持下,复制原数组的基础上创造一个新的容量+1的复制数组.然后将set的值写入到新的复制数组中
	**互斥规则**
	写-写：互斥，阻塞
	读-写：互斥(由数组副本支持)
	读-读：不互斥
	CopyOnWriteArrayList比直接使用读写效率高

CopyOnWriteArrayList
	底层是由CpoyOnWriteArrayList支持的set,共享许多基本属性
	**互斥规则**
	写-写：互斥，阻塞
	读-写：不阻塞,但是线程安全
	读-读：不互斥,不阻塞
	**可以理解为带set特性的CopyOnWriteArrayList**
HashTable
	底层还是一个哈希表,该哈希表将键映射到对应的值
	任何非null对象都可以用作键或值
	很多方法使用了synchroniezd来保证线程安全
	互斥规则
	写-写：互斥，阻塞
	读-写：互斥
	读-读：互斥
	**相当于线程安全的HashMap**
Queue
	Collection的子接口，表示队列FIFO(First In First Out)
	先进先出
	//链表组合的方法 add remove
	//队列的方法 offer peek poll
	**注意事项**:
	要么作为链表使用,要么作为队列使用
	不要同时使用list的方法和queue的方法
ConcurrentLinkedQueue
	一个基于链接节点的无界线程安全队列.
	无锁,但是有CAD比较交换算法,
	所以是一个线程安全,又可以高效读写的队列,高并发下性能最好的队列
BlockingQueue
	概述:Queue的子接口 支持两个附加操作的 [Queue](../../../java/util/Queue.html)，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。
	  ![[多线程-线程安全_image_1.jpg]]
	超时:如果空间不够用,在time时限内如果扩容了则可行,如果超过时限则失败并取消本次操作
	底层代码long nanos = unit.toNanos(timeout);
	子类:**ArrayBlockingQueue**
		一个数组支持的有界的阻塞队列,上限手动给出
	子类:**LinkedBlockingQueue**
		无界的队列
**ConcurrentHashMap**
	1. 键当中放哈希吗值
	2. 数组,链表,二叉树
	3. 列表线程安全问题由CAS比较算法支持(通过CAS和Synchonize保证同步)
	4. 线程安全问题基本都是独立的,不阻塞
	5. 跟HashMap相比是一个线程安全并且速度快的集合



java中常见原子性操作
	**原子性操作**:最小的操作量级,不能再被切割成多个操作(多个操作会导致多线程数据不准确)
	1、除long和double之外的基本类型的赋值操作(因为long和double是64位而部分cpu字长是32位需要2次操作)
	2、所有引用reference的赋值操作 
	3、java.concurrent.Atomic.* 包中所有类的一切操作
线程安全不一定要有synchronized或者lock.可以由代码来完成
**CAS概念**:
	compare and swap 比较和交换
	没有任何阻塞但保证了线程安全
	V:variable要修改的变量
	E:exptected 期望值
	N:new 新值
	就是认准V修改
	而多条线路执行时E可能会被修改这时
	CAS会自旋重新生成对应E的值

什么是自旋？
	很多 synchronized 里面的代码只是一些很简单的代码，执行时间非常快，此时等待的线程
	都加锁可能是一种不太值得的操作，因为线程阻塞涉及到用户态和内核态切换的问题。既然synchronized 里面的代码执行得非常快， 不妨让等待锁的线程不要被阻塞， 而是在synchronized 的边界做忙循环（不放弃cpu而作的空循环），这就是自旋。如果做了多次忙循环发现还没有获得锁，再阻塞，这样可能是一种更好的策略。
	如果要修改一个数组中的 1 为 2
	则这个1为期望值:代表如果是1则修改
	则E在的地方称为V
	要修改的值2 为N
Vector
	特性:可以增加和删除的容量可变的对象数组
	互斥规则
	写-写：互斥，阻塞
	读-写：互斥、阻塞
	读-读：互斥、阻塞
	总结:效率低下,使用和arrayList无区别
CpoyOnWriteArrayList
	arrayList的一个线程安全的变体,其中操作(add.set,等等)都是通过对底层数组进行一次新的复制来实现的
	//读没有不同,就是对原数组的数值进行读取
	//写add,set,...在底层代码的支持下,复制原数组的基础上创造一个新的容量+1的复制数组.然后将set的值写入到新的复制数组中
	**互斥规则**
	写-写：互斥，阻塞
	读-写：互斥(由数组副本支持)
	读-读：不互斥
	CopyOnWriteArrayList比直接使用读写效率高

CopyOnWriteArrayList
	底层是由CpoyOnWriteArrayList支持的set,共享许多基本属性
	**互斥规则**
	写-写：互斥，阻塞
	读-写：不阻塞,但是线程安全
	读-读：不互斥,不阻塞
	**可以理解为带set特性的CopyOnWriteArrayList**
HashTable
	底层还是一个哈希表,该哈希表将键映射到对应的值
	任何非null对象都可以用作键或值
	很多方法使用了synchroniezd来保证线程安全
	互斥规则
	写-写：互斥，阻塞
	读-写：互斥
	读-读：互斥
	**相当于线程安全的HashMap**
Queue
	Collection的子接口，表示队列FIFO(First In First Out)
	先进先出
	//链表组合的方法 add remove
	//队列的方法 offer peek poll
	**注意事项**:
	要么作为链表使用,要么作为队列使用
	不要同时使用list的方法和queue的方法
ConcurrentLinkedQueue
	一个基于链接节点的无界线程安全队列.
	无锁,但是有CAD比较交换算法,
	所以是一个线程安全,又可以高效读写的队列,高并发下性能最好的队列
BlockingQueue
	概述:Queue的子接口 支持两个附加操作的 [Queue](../../../java/util/Queue.html)，这两个操作是：获取元素时等待队列变为非空，以及存储元素时等待空间变得可用。
	  ![[多线程-线程安全_image_1.jpg]]
	超时:如果空间不够用,在time时限内如果扩容了则可行,如果超过时限则失败并取消本次操作
	底层代码long nanos = unit.toNanos(timeout);
	子类:**ArrayBlockingQueue**
		一个数组支持的有界的阻塞队列,上限手动给出
	子类:**LinkedBlockingQueue**
		无界的队列
**ConcurrentHashMap**
	1. 键当中放哈希吗值
	2. 数组,链表,二叉树
	3. 列表线程安全问题由CAS比较算法支持(通过CAS和Synchonize保证同步)
	4. 线程安全问题基本都是独立的,不阻塞
	5. 跟HashMap相比是一个线程安全并且速度快的集合



java中常见原子性操作
	**原子性操作**:最小的操作量级,不能再被切割成多个操作(多个操作会导致多线程数据不准确)
	1、除long和double之外的基本类型的赋值操作(因为long和double是64位而部分cpu字长是32位需要2次操作)
	2、所有引用reference的赋值操作 
	3、java.concurrent.Atomic.* 包中所有类的一切操作
**线程是作为调度和分配的基本单位,进程是拥有资源的基本单位**
**什么情况下该考虑多线程?**
	1.当程序需要同时执行多个任务时,使用多线程并发执行
	2. 当程序需要等待某个操作完成时，可以使用多线程来避免阻塞主线程，从而提高程序的响应速度。
	3. 当程序需要定时执行某个任务时，可以使用多线程来实现定时任务的功能。
	4. 当程序需要处理大量数据时，可以使用多线程来对数据进行分片处理，从而提高程序的处理速度。
**多线程的作用:**
	多线程并发可以发挥多核cpu的优势提高程序的效率,可以同时完成多项工作防止阻塞,并且利于构建复杂的任务模型
**线程的5中状态**
	1.新建:创建了线程对象
	2.可运行对象:就绪状态可运行但还没拿到CPU的执行权
	3.运行:拿到了CPU的执行权,并执行线程
	4.死亡:线程运行结束
	5.阻塞:休眠线程,加入线程,等待线程,同步,....等
	6.超时等待状态
**run()和start()的区别**
	`run()`方法定义了线程的主体，也就是线程要执行的代码。当我们直接调用`run()`方法时，它会在当前线程中执行，而不会创建新的线程。
	`start()`方法则是用于启动一个新线程，并让新线程去执行`run()`方法中的代码。当我们调用`start()`方法时，它会创建一个新的线程，并在新线程中执行`run()`方法中的代码。
Thread运行多线程和Runnable运行多线程的差别
	**Thread运行多线程步骤**
	创建一个类继承Thread方法,并且重写run方法
	在main方法内创造子类对象,使用父类的start方法运行
	1使用Thread继承方法来保证多线程运行run方法是运行的Thread的run方法且没有创造Runnable对象.而没有使用Runnable的run方法,缺点不能有继承其他父类,因为继承只能单继承,但是可以直接使用Thread中的方法
	**runnable运行多线程步骤**
	创建一个类实现runnable接口,并且重写run方法
	在main中创建Runnable对象
	使用有参构造创建Thread对象传入Runnable对象
	再使用Thread对象调用start方法
	2使用Runnable的实现接口方法时候会使用Runnable方法中的run方法.缺点不能直接使用Thread中的方法,但是可以不影响继承其他父类
	**第三种使用匿名内部类方法去调用,目的是代码简化**
Thread中的方法
	1.获取名字
	通过getName()方法获取线程对象的名字
	2.设置名字
	通过构造函数可以传入String类型的名字
	3.获取当前线程对象(也可以获取主线程)
	Thread.currentThread()
	Thread.Sleep()方法:休眠线程
	Thread.setDaemon()方法:守护线程
		//当普通线程执行完后守护线程不会执行  常见入垃圾回收线程就是守护线程
	Thread.jion()方法:加入线程
		//当前线程暂停,等待加入线程执行结束后再执行
		或者输入int值等待int毫秒值后再执行
	Thread.setPriority()方法:设置线程优先级
		//取值范围为1-10,值越高优先级越高,执行次数越多
多线程间的通信
	什么时候需要通信:
	多个线程并发执行时,在默认情况下CPU是随机切换线程的
	我们希望他们有规律的执行,就可以使用通信,例如每个线程执行一次打印
	如果希望线程等待, 就调用wait()
	如果希望唤醒等待的线程, 就调用notify();
	这两个方法必须在同步代码中执行, 并且使用同步锁对象来调用
同步代码块-线程安全
	synchronized(对象):同步代码块
	如果要锁两个运行同步,就把输入对象相同
	多个同步代码块如果使用相同的锁对象,name他们就是同步的
	使用synchronized关键字修饰一个方法, 该方法中所有的代码都是同步的
	什么情况下需要同步
	当多线程并发, 有多段代码同时执行时, 我们希望某一段代码执行的过程中CPU不要切换到其他线程工作. 这时就需要同步.
	如果两段代码是同步的, 那么同一时间只能执行一段, 在一段代码没执行结束之前, 不会执行另外一段代码
	同步方法,即将synchronized假如方法说明中.代表这个方法是同步的
	静态同步方法和普通同步方法锁的对象不同
	普通同步方法:锁的是当前对象
	静态同步方法:锁的是当前对象的运行时对象
线程安全(Lock锁)
	Lock锁实现提供了比使用synchronized方法和语句可获得的更广泛的锁定操作.
	步骤:
	在成团变量的位置上创建lock对象
	在需要同步的代码开始处使用lock方法,在结束处使用unlick方法
**死锁:**
	死锁是指两个或两个以上的进程在执行过程中，由于竞争资源或者由于彼此通信而造成的一种阻塞的现象，若无外力作用，它们都将无法推进下去。此时称系统处于死锁状态或系统产生了死锁，这些永远在互相等待的进程称为死锁进程。
**死锁的4个必要条件(取消一个便可避免死锁)**
	1、互斥条件：一个资源每次只能被一个进程使用；
	2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
	3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；
	4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系；


ReentrantLock
	Lock接口的实现类,与synchronized一样具有互斥功能
	互斥规则:
	写-写互斥
	读-写互斥
	读-读互斥
	创建一个ReetrantLock对象后使用lock方法锁
	unlock方法解锁
ReentrantReadWriteLock（因为多次读并发并不会影响结果所以读读不互斥但是写会）
	一种支持一写多读的同步锁,读写分离,可分别分配读锁.写锁
	支持多次分配读锁,使多个读操作可以并发执行
	内部类ReadLock、WriteLock分别是Lock的实现类
	互斥规则:
	写-写 互斥,
	读-写 互斥
	读-读 不互斥

---
## 线程池
**线程池作用和原理:**
	**作用:**
	1.优化线程频繁创建和销毁导致的资源浪费
	**原理:**
	创建一个容器放入固定线程,需要的时候拿出用完后放回

线程池例子
	ExecutorService xxx = Executors.newFixedThreadPool(2);
	变量名.submit(线程对象);提交一个Runnable对象用于执行
	返回一个Future对象.泛型类型根据返回值类型确定
	返回值类型可在Runnable对象泛型确定时确定
	变量名.shutdown
	//结束线程池,不再接受新的任务,原有的任务继续执行
	while(!变量名.isTerminated){}
	//isTerminated返回值如果是false代表还未执行完毕
	所以设置一个!反向,如果还未执行完则死循环继续执行
	如果执行完则跳出循环
线程池使用场景和如何使用
	**场景**:
	线程频繁创建和销毁的情况下创建线程池
	**使用细节**:
	1. 尽量做全局变量而不要使用局部变量(避免重复创建线程池)
	2. 使用ioc反向代理创建而不要使用new(避免重复线程池创建)
shutdown()方法是如何让线程池被回收的?
	1. 线程池调用shutdownnow方法是为了调用worker对象的interrupt方法，来打断那些沉睡中的线程（waiting或者time_waiting状态），使其抛出异常
	2. 线程池会把抛出异常的worker对象从workers集合中移除引用，此时被移除的worker对象因为没有到达gc root的路径已经可以被gc掉了
	3. 等到workers对象空了，并且当前tomcat线程也结束，此时线程池对象也可以被gc掉，整个线程池对象成功释放

并发执行和并行执行的区别:
	**并行执行:**
	真正的任务同时执行
	两个人物分配两个CPU
	缺点:对CPU的耗费大
	**并发执行:**
	虚假的同时执行
	实际是两个任务以非常快的速度争抢CPU的执行权
	串行:
	一个任务等待上个任务执行完再执行


---
## 多线程实际应用问题
当我们需要所有线程都执行到某一处，才进行后面的的代码执行我们可以使用？
	**CyclicBarrier类**    [详解CyclicBarrier类](https://blog.csdn.net/ThinkWon/article/details/102556958)
	CountDownLatch一般用于某个线程A等待若干个其他线程执行完任务之后，它才执行； 而CyclicBarrier一般用于一组线程互相等待至某个状态，然后这一组线程再同时执行； 另外，CountDownLatch是不能够重用的，而CyclicBarrier是可以重用的
**yield()和join()区别**
	yield方法是让其他线程有机会和他竞争(不释放锁)
	join方法是让本线程阻塞直到指定线程运行完毕(只会释放Thread的锁，不会释放线程对象的锁（可能会造成死锁）)
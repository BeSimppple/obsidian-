**集合的特性**
	1. 集合中只能存放引用数据类型(不能存放基础数据类型),jdk5之后就提供了自动装箱和拆箱
**你所知道的集合类都有哪些？主要方法？**
	1.ArrayList 2.LinkedList 3.Vector 
	4.HashTable 5.HashMap 6.TreeMap
	 7.TreeSet 8.SortSet 9.HashSet
	 常用方法也就是概念思想特别点  iterator在list和set中作为提取遍历
	 map中有add和containKey 还有 EntrySet返回所有键值
List循环删除元素为什么要使用iterator()
	因为普通for循环remove删除后整体元素大小和下标变动会导致后续的下标错误,增强for循环则数据的添加或删除都会触发 fast-fail，导致抛出异常
	**iterator()原理**:
	Iterator 的底层原理则是通过三个实例变量，控制遍历的前后坐标及标记数据结构修改次数状态来保证遍历中的数据操作正确性。
	(1) 使用方法iterator()要求容器返回一个Iterator。第一次调用Iterator的next()方法时，它返回序列的第一个元素。注意：iterator()方法是java.lang.Iterable接口,被Collection继承。
	(2) 使用next()获得序列中的下一个元素。
	(3) 使用hasNext()检查序列中是否还有元素。
	(4) 使用remove()将迭代器新返回的元素删除。
**Hashmap扩容机制**
	一般情况下，**当元素数量超过阈值时便会触发扩容**。每次扩容的容量都是之前容量的2倍。
	HashMap的容量是有上限的，必须小于**1<<30**，即1073741824。如果容量超出了这个数，则不再增长，且阈值会被设置为Integer.MAX_VALUE（ 231−1 ，即永远不会超出阈值了)
	注意:首次生成hashmap是空数组会触发扩容再放入数据,后续的都是放入数据再确定是否需要扩容
	**JDK7以前**:
		1. 空参数的构造函数：以默认容量、默认负载因子、默认阈值初始化数组。内部数组是**空数组**
		2. 有参构造函数：根据参数确定容量、负载因子、阈值等。
		3. 第一次put时会初始化数组，其容量变为**不小于指定容量的2的幂数**。然后根据负载因子确定阈值。
		4. 如果不是第一次扩容，则 新容量旧容量新容量=旧容量×2 ， 新阈值新容量负载因子新阈值=新容量×负载因子 。
	**JDK8以后**:
		1. 空参数的构造函数：实例化的HashMap默认内部数组是null，即没有实例化。第一次调用put方法时，则会开始第一次初始化扩容，长度为16。
		2. 有参构造函数：用于指定容量。会根据指定的正整数找到**不小于指定容量的2的幂数**，将这个数设置赋值给**阈值**（threshold）。第一次调用put方法时，会将阈值赋值给容量，然后让 阈值容量负载因子阈值=容量×负载因子 。（因此并不是我们手动指定了容量就一定不会触发扩容，超过阈值后一样会扩容！！）
		3. 如果不是第一次扩容，则容量变为原来的2倍，阈值也变为原来的2倍。_（容量和阈值都变为原来的2倍时，负载因子还是不变）_
**hash冲突的处理**
	1. **开放寻址法**：又称开放定址法，当哈希冲突发生时，从发生冲突的那个单元起，按照一定的次序，从哈希表中寻找一个空闲的单元，然后把发生冲突的元素存入到该单元。这个空闲单元又称为开放单元或者空白单元。开放寻址法需要的表长度要大于等于所需要存放的元素数量，非常适用于装载因子较小（小于0.5）的散列表。查找时，如果探查到空白单元，即表中无待查的关键字，则查找失败。
		**缺点**:删除元素的时候不能真的删除，否则会引起查找错误，只能做一个特殊标记，直到有下个元素插入才能真正删除该元素。(类似找停车位)
	2. **再散列法**：Hi=HASHi(key), i=1,2,…,k. HASHi均是不同的散列函数，即在key产生地址冲突时计算另一个散列函数地址，直到冲突不再发生，这种方法不易产生“聚集”，但增加了计算时间。
	3. **线性探查法**(Linear Probing)是开放定址法中最简单的冲突处理方法，它从发生冲突的单元起，依次判断下一个单元是否为空，当达到最后一个单元时，再从表首依次判断。直到碰到空闲的单元或者探查完全部单元为止。容易产生堆聚现象
	4. **平方探测法**: 对于已经计算出来的哈希值H 如果发生冲突 那么下一个放入的位置是 (H + i2) % 11 (H - i2) % 11 其中i的值为1，2，...
		平方探测法不能探查到全部剩余的桶。不过在实际应用中，散列表如果大小是素数，并且至少有一半是空的，那么，总能够插入一个新的关键字。若探查到一半桶仍未找一个空闲的，表明此散列表太满，应该重哈希。平方探测法是解决线性探测中一次聚集问题的解决方法，但是，她引入了被称为二次聚集的问题——散列到同一个桶的那些元素将探测到相同的备选桶。
Collection框架中实现比较要实现什么接口
	comparable/comparator接口
**ArrayList和Vector的区别**
	ArrayList是线程不安全的有序集合
	Vector是线程安全的
	Vector有主动扩容的方法
	还有细微的差别是ArrayList默认扩容是1.5倍 Vector是2倍
HashMap和Hashtable的区别
	HashMap是线程不安全的键值对形式的底层是数组+链表形式 通过Hash对键进行去重 允许Null作为间值
	HashTable是线程安全的且不允许Null值作为键值
List 和 Map 区别?
	List是存储单列数据的集合且是有序的允许重复,Map是双列数据键值不允许重复
List, Set, Map是否继承自Collection接口,三个接口，存取元素时，各有什么特点?
	List和Set是,Map不是
	List可重复,有序   Set去重,无序(hashcode排序)  Map双列,键值去重,无序





















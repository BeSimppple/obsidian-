**异常的作用和分类**
	**作用**:
	抛出异常更快检查到具体的问题
	**分类**:
	**Throwable类:是Java程序在运行过程中出现的问题,是 Java 语言中所有错误或异常的超类**。
	Throwable的子类:
		**Error**:错误
		服务器宕机,数据库崩溃等(java程序员一般无法处理)
		**Exception**:异常(能处理,需要处理)
		**Exception分为两种类型，一种为Checked Exception，另一种为unchecked Exception**
		Checked Exception，比如最常见的IOException，这种异常需要调用处显式处理，要么使用try catch捕获，要么再次抛出去。
		Unchecked Exception指的是所有继承自Error（包含自身）或者是RuntimeException（包含自身）的类。这些异常不强制在调用处进行处理。但是也可以try catch处理。
异常的系统开销和if判断返回false的开销
	**因为函数调用(if或其他函数)是入栈出栈，栈是在寄存器之下的速度最快，且占的空间少，而自定义异常是存在堆中，肯定异常的内存开销大！**

**JVM默认如何处理异常**
	如果开发人员没有针对的处理方式,只有交给调用main的jvm来处理 jvm有一个默认的异常处理机制,就将该异常进行处理.并将该异常的名称,异常的信息.异常出现的位置打印在了控制台上,同时将程序停止运行.
	try...catch
	try catch//1
	try catch finally//2
	try finally//3
	常用前两种
	try检测异常
	catch处理异常
	finally释放资源
	//如果要处理多个异常那么可以直接用他们的父类Exception
	(其实就是父类引向子类就是多态)
	如果处理几个异常可以采用位或( | )的方式
**编译期异常和运行期异常的区别**
	**运行时异常**
	1. 直接继承或者间接继承RuntimeException的类
	2. 在运行时才会出现!不需要在编译期间处理!
	**编译期异常**
	1. 除运行时异常以外都是编译期异常
	2. 一般直接继承Exception或间接继承
	3. 必须在编译期对异常进行处理，否则编译不通过，不能运行!
	**常见编译期异常**:
		1. IOException
		2. SQLException
		3. FileNotFoundException(继承与IOException)
Throwable的常见几个方法
	e.toString();//错误类型,错误原因
	//返回字符串
	e.getMessage();//错误原因
	//返回字符串
	e.printStackTrace();//错误类型,错误原因,错误位置
	//返回void
	常用e.printStacktrace();
	throws的方式处理异常
throws关键字
	throws会一步一步向父类抛错误最后到JVM
	可以用逗号,分隔来载入2个声明
	**例子**:public static void divide()throws ArithmeticException ,NumberFormatException{
	**特点**:throws处理异常,如果产生异常,程序会异常终止
	**方式**:定义功能方法时，需要把出现的问题暴露出来让调用者去处理。那么就通过throws在方法上标识。
**throw关键字**
	主动抛出错误(已存在类型Exception或自定义)
	**书写格式例**:
	throw new AgeLegalException("你他娘的不是人么");
	throw new 错误方法类();
**抛出异常的注意事项**
	1:子类重写父类方法时，子类的方法必须抛出相同的异常或父类异常的子类(适用于编译期异常)
	2如果被重写的方法(父类的方法)没有异常抛出,那么子类的方法绝对不可以抛出异常,如果子类方法内有异常发生,那么子类只能try,不能throws
throws和throw的区别
	1.throws 用在方法声明后面，跟的是异常类名 可以跟多个异常类名，用逗号隔开 表示抛出异常，由该方法的调用者来处理
	2.:throw 用在方法体内，跟的是异常对象 只能抛出一个异常对象 表示抛出异常，由方法体内的语句处理
**finally关键字**
	**特点**:
	被finally控制的语句体一定会执行
	**作用**:
	用于释放资源，在IO流操作和数据库操作中会见到
	**特殊情况**：
	**1. finally遇到结束程序**
	在执行到finally之前jvm退出了(比如System.exit(0))
	**2. finally遇到return**
	finally 在return 之后时，先执行finally 后，再执行该return；finally 内含有return 时，直接执行其return 后结束；finally 在return 前，执行完finally 后再执行return
	**Return并不是让函数马上返回，而是return语句执行后，将把返回结果放置进函数栈中，此时函数并不是马上返回，它要执行finally语句后才真正开始返回。**


**反射的作用和原理(使用场景)**
	**作用**:
		1. 动态加载类
		2. 运行时分析类的结构
		3. 访问类的私有成员
		4. 实现通用的框架和工具
			许多框架和工具，如Java的注解处理器、ORM框架、序列化库等，都使用了反射。通过反射，这些框架和工具可以在运行时动态地分析和操作类的结构，实现各种功能。
		5. 实现序列化和反序列化
		6. 实现动态代理对象
	**原理**:
		1. **获取Class对象**：要使用反射，首先需要获取要操作的类的Class对象。可以通过多种方式获取Class对象，包括使用类字面常量（如`ClassName.class`）、使用`Class.forName()`方法传入类名、或通过已有对象的`getClass()`方法等。
		2. **Class对象的加载和链接**：当获取到Class对象后，JVM会负责加载和链接该类。加载阶段将类的字节码文件加载到内存，并在方法区中创建对应的Class对象。链接阶段主要包括验证、准备和解析步骤，用于确认类的正确性、分配静态变量的内存空间以及将符号引用转换为直接引用。
		3. **获取类的结构信息**：一旦有了Class对象，就可以使用反射获取类的结构信息，如字段、方法、构造函数、注解等。这些信息存储在类的Class对象中，可以通过调用相应的方法（如`getDeclaredFields()`、`getDeclaredMethods()`等）来获取。
		4. **动态创建对象**：通过反射，可以使用Class对象动态地创建对象实例。可以使用`newInstance()`方法创建一个类的新实例，或者通过构造函数相关的方法（如`getDeclaredConstructor()`、`newInstance()`）创建带有特定参数的实例。
		5. **调用对象的方法和访问字段**：反射允许调用对象的方法和访问字段，包括公有和私有的方法和字段。可以使用`getMethod()`、`getField()`等方法获取特定的方法和字段，然后使用`invoke()`方法调用方法或`set()`、`get()`方法设置和获取字段的值。
	**使用场景**:
		1. 需要运行时获取对象,例如jdbc链接数据库需要动态的获取
		2. spring的XML配置(很多框架底层都是通过反射来实现的配置)
		3. 需要访问类的私有成员或方法
		4. 生成动态代理的对象
		5. 序列化和反序列化(射提供了一种机制来动态地读取和写入对象的状态，从而实现对象的序列化和反序列化)
	**缺点**:
		1. 相比于使用创建好的实例类,反射是调用JVM来获取类速度更慢资源消耗更多
		2. 反射的出现一定程度打破了JAVA的"封装"特性(因为可以通过反射强制获取private修饰的属性和方法)



---
## 类的加载
**类的加载流程**(一般类的加载)
	当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过**加载，连接，初始化**
	三步来实现对这个类进行初始化。
	1. 加载就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。//class也就是运行时对象
	2. 连接
	3. 验证 是否有正确的内部结构，并和其他类协调一致
	4. 准备 负责为类的静态成员分配内存，并设置默认初始化值
	5. 解析 将类的二进制数据中的符号引用替换为直接引用
	6. 初始化 就是对变量的初始化
**加载时机**
	1. 创建类对象的实例
	2. 访问类的静态变量，或者为静态变量赋值
	3. 调用类的静态方法
	4. 使用反射方式来强制创建某个类或接口对应的java.lang.Class对象
	5. Class.forName("com.mysql.jdbc.Driver");创建了Driver类的运行时对象
	6. 初始化某个类的子类
	7. 直接使用java.exe命令来运行某个主类
**类加载器的概述**
	负责加载Java 类的字节码（ .class 文件）到JVM 中（在内存中生成一个代表该类的 Class 对象）。这个过程包括，读取字节数组、验证、解析、初始化等。另外，它也可以加载资源，包括图像文件和配置文件。
**类加载器的分类**
	从父类到子类排序	
	1. Bootstrap ClassLoader 根类加载器
	1. Extension ClassLoader 扩展类加载器
	2. AppClass ClassLoader 应用类加载器
	4.自定义类加载器
		除了 `BootstrapClassLoader` 其他类加载器均由 Java 实现且全部继承自`java.lang.ClassLoader`。如果我们要自定义自己的类加载器，很明显需要继承 `ClassLoader`抽象类。
	**作用:**
	1. Bootstrap ClassLoader 根类加载器(也被称为引导类加载器)
	最顶层的加载类，由 C++实现，通常表示为 null，并且没有父级，主要用来加载 JDK 内部的核心类库（ %JAVA_HOME%/lib目录下的 `rt.jar` 、`resources.jar` 、`charsets.jar`等 jar 包和类）以及被 `-Xbootclasspath`参数指定的路径下的所有类。
	2. Extension ClassLoader 扩展类加载器
	(主要负责加载 %JRE_HOME%/lib/ext目录下的 jar 包和类以及被 `java.ext.dirs` 系统变量所指定的路径下的所有类。)
	3. AppClass ClassLoader 系统类加载器
	(面向用户的加载器,负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar包和类路径)
**反射概述**
	JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；
	对于任意一个对象，都能够调用它的任意一个方法和属性；
	这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

在原码期间获取Class对象的方法:
class.forName(class全限定类名);
在编译期间获得class对象的方法
类名.class;
在运行时获得class对象的方法:
new 对象名().getclass();
要想解剖一个类,必须先要获取到该类的字节码文件对象就是Class对象。
而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的
对象。
B:三种方式
a:Object类的getClass()方法,判断两个对象是否是同一个字节码文件
b:静态属性class,锁对象
c:Class类中静态方法forName(),读取配置文件
反射结合工厂模式
工厂案例,就是使用反射来减少耦合,更方便的调用和减少代码的使用量,使用反射直接调用class对象
public static Fruit buy(String Classname) throws Exception {
Fruit fruit = (Fruit) Class.forName(Classname).newInstance();
//使用反射获取到输入的当前class,然后使用里面的newInstance方法创建一个新的实例对象.将他强转成我们需要的类的类型
return fruit;
}
当有多种水果继承父类fruit时候
每次调用对象水果需要先引用对象
例如:Apple apple = new Apple();
但是使用工厂静态方法
public static Fruit getFruit(String name){//直接调用水果.然后判断再调用其中的内容
//工厂主要解决结藕问题
if (name.equals("苹果")){
return new Apple("苹果");
}else if(name.equals("柠檬")){
return new lemon("柠檬");
}
return null;
}
在结合反射
//需要水果的全限定类名
//反射主要解决种类过多else,if代码过多问题
public static Fruit getFruit2(String name) throws Exception {
return(Fruit)Class.forName(name).newInstance();
}
当有多种水果时候不用调用每种水果的对象后再引用
可以直接反射调用
Fruit fruit2 = FruitFactor.getFruit2("Com.YL.Bean.Apple");//通过第二种拿到苹果水果对象
System.out.println(fruit2);
Fruit fruit1 = FruitFactor.getFruit2("Com.YL.Bean.lemon");//通过第二种拿到柠檬水果对象
System.out.println(fruit1);
通过反射操作构造方法创建对象
这里告诉我们反射可以通过Constructor方法使用公用的构造方法,也可以通过getDeclaredConstructor方法获取私用的构造器方法,然后启动暴力反射允许访问,最后使用Constorcutor的newInstance创建实例对象.打印
Consturctor和Filed都继承与类 AccessibleObject所以能用setAccessible()方法
Class<Teacher> clazz = Teacher.class;//获取字节码对象,创造对象Teacher
//暴力反射
Constructor<Teacher> declaredConstructor = clazz.getDeclaredConstructor(String.class);
public [Constructor](../../java/lang/reflect/Constructor.html)<[T](../../java/lang/Class.html)> getConstructor
([Class](../../java/lang/Class.html)<?>... parameterTypes)
//这个方法要传入的参数是:参数类型的class对象
例如:String则传入String.class
declaredConstructor.setAccessible(true);
Teacher teacher04 = declaredConstructor.newInstance("尼玛");
System.out.println(teacher04);
通过反射调用成员变量
Class<Teacher> clazz = Teacher.class;//获取字节码对象
Teacher teacher = clazz.newInstance();
//创建实例对象teacher
//暴力反射获取
Field name1 = clazz.getDeclaredField("name");
name1.setAccessible(true);//让其合法被访问
name1.set(teacher,"老王"); System.out.println(name.get(teacher));
System.out.println(name1.get(teacher));
反射实际使用:写一个"框架",在不改变任何代码的前提下,创建任意类的对象,并且执行其中任意方法
步骤1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中
步骤2.在程序中加载读取配置文件
2.1创建Properties对象
2.2获取Class目录下的配置文件
//获取 当前类 这个字节码文件对应的类加载器
类名.class.getClassLoader();
//返回这个资源对应的字节流
类加载器.getResourceAsStream(配置文件);
Properties对象.load()
2.3获取所需配置文件中定义的数据
String str = pro对象名.getProperty("数据名");
步骤3.使用反射技术来加载类文件进内存
步骤4/创建对象
步骤5.执行方法
反射的通用方法
创建一个方法,将需要的参数写好
//需求给指定对象的指定属性设置指定值
//指定对象不知道类型设定obj,指定属性名String,目标对象类型未知设定obj
public static void method(Object obj1,String filedName,Object obj2) throws Exception {
Class<?> clazz = obj1.getClass();//拿到指定对象的class
Field f = clazz.getDeclaredField(filedName);
f.setAccessible(true);
f.set(obj1,obj2);
//打印
System.out.println(obj1);
}
}
底层代码就是方法method的反射实现功能
执行:method(new Person(),"name","二狗");
反射越过泛型检查
原理:java中的反省检查生命周期只在源码阶段
故而通过反射运行时泛型检查已经没有
反射通用方法:给指定对象的指定属性设置指定值
public static void method(Object obj1,String filedName,Object obj2) throws Exception {
}
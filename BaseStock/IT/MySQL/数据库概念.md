**什么是数据库:**
	数据库就是一个文件系统,但是这个文件访问需要通过标准SQL语句
**数据库分类**
	关系型数据库定义:以表格的形式组织，每个表格包含若干行数据，每行数据包含若干列属性
	关系型数据库
		MYSQL, SQLServer, Oracle ,DB2, SyBase, SQLite
	非关系型数据库
		redis
		mongodb
MySQL内部存储结构
	一个软件对应一个数据库,在数据库内部可以存在多张表:
	一个实体类对应一张表.表中可以有多条记录的
	.一般情况下：一类的实例对应一条记录
什么是SQL?
	SQL:Structured Query Language.结构化查询语言
SQL分类
	DDL(Data Definition Language)
	数据定义语言
	DML(Data Manipulation Language)
	数据处理语言
	DQL(Data Query Language)
	数据查询语言
	DCL(Data Control Language)
	数据控制语言
MySQL的常用类型(对应Java类型)
	java类型--- MySQL类型
	String ---CHAR/VARCHAR
	byte ---TINYINT
	short ---SMALLINT
	int ---INT
	long ---BIGINT
	float ---FLOAT
	double ---DOUBLE
	boolean ---BIT
	date ---DATE/TIME/DATETIME/TIMESTAMP
**MySQL整个查询的过程**
	1.  客户端先发送查询语句给服务器
	2.  服务器检查缓存，如果存在则返回
	3.  进行sql解析，生成解析树，再预处理，生成第二个解析树，最后再经过优化器，生成真正的执行计划
	4.  根据执行计划，调用存储引擎的API来执行查询
	5.  将结果返回给客户端。

---
## Mysql事务
概念:
	一条或者多条SQL语句组成一个执行单元
	特点:同时成功或同时失败相互依赖成一整体
	如果某条sql语句执行错误或失败你那么整个单元就会回滚到事务最初状态,如果都执行成功,则事务就顺利进行.
事务管理语法:
	start transaction //开启事务,开启后数据都是临时的,需要回滚或者提交才生效
	rollback //将数据回滚到开启事务之前,然后结束事务
	commit //提交数据到数据库,然后结束事务 提交后才是真的数据"持久化"也是真的写入数据库
事务的提交方式:
	自动提交:由系统自动提交
	手动提交:由程序员代码提交
	select @@AUTOCOMMIT; 返回值:1或0
	1代表自动提交,0代表手动提交
	set @@AUTOCOMMIT =数字;
**Mysql中事务实现原理:**
	MySQL中的事务是通过ACID（原子性、一致性、隔离性和持久性）属性来保证数据的完整性和一致性的
	原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql
	一致性：由其他三大特性共同保证，是事务的目的
	隔离性：由MVCC(多版本并发控制)保证
	持久性：由redo log日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复
**事务的四大特征**
	**原子性（atomicity）**
	是不可分割的最小操作单位，要么同时成功，要么同时失败。
	**持久性（consistency）**
	当事务提交或回滚后，数据库会持久化的保存数据。
	**隔离性（isolcation）**
	多个事务之间。相互独立。
	事实上事务之间是存在一定的影响的，需要理解隔离级别。
	**一致性（durability）**
	事务操作前后，数据总量不变
	比如：转账前后，两个用户的金额总数不变。
**事务的隔离级别**
	**概念:** 多个事务之间隔离的,相互独立的,但是如果多个事务并发操作同一批数据,则会引发一些问题,设置不同的隔离级别就可以解决这些问题.
	**隔离级别**
	1.读未提交 read uncommitted
	//可以读到未提交的数据
	存在问题:1.脏读2.不可重复读3.幻读
	2.读已提交 read committed
	//存在不可重复读,因为每次读取数据不一样
	存在问题:1.不可重复读2.幻读
	3.可重复读 repeatable read
	//存在幻读问题
	存在问题:1.幻读
	4.串行化 serializable
	//线程安全,速度极慢一般不用
	不存在问题
脏读
	是指在一个事务处理过程中读取了另一个未提交的事务中的数据 , 导致两次查询结果不一致
不可重复读(mysql隔离级别:默认不可重复读)
	是指在一个事务处理过程中读取了另一个事务中修改并已提交的数据, 导致两次查询结果不一致
	(读取数据的一方 被写入的那方改变了一次的读取数据结果
	写入开启事务同时读取开始事务
	此时写入临时数据,读取事务数据不改变
	此时提交数据成"持久性"数据,读取事务数据被改变
	在一次读取中事务还未提交时数据 读取到的数据不应该被改变
	)
幻读
	select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入。或不存在执行delete删除，却发现删除成功
	(搜索记录显示不存在,而插入时却显示已经存在)
	(可以用多线程理解,A事务处理时准备插入这个记录但是还未提交,B检索到没有这个数据也准备插入并提交,
	但是此时A完成事务提交,最后B报错存在此条记录)

---
## 数据库设计范式:
第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
一般达到第三范式即可-[图解](https://www.boxuegu.com/news/4803.html)
第一范式（1NF）：
	每一列都是不可分割的原子数据项
第二范式（2NF）：
	在1NF的基础上，非码属性必须完全依赖于主码
	（在1NF基础上消除非码属性对主码的部分函数依赖）
	让不是绝对函数依赖的另外建立一张表形成联系
第三范式（3NF）：
	在2NF基础上，消除传递依赖
	第三范式为了让数据更好修改,而不会成为脏数据
码:
	如果在一张表中，一个属性或属性组，被其他所有属性所完全函数依赖，则称这个属性(属性组)为该表的码 例如：该表中码设置为（学号，课程名称）
函数依赖：
	A-->B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号-->姓名。 （学号，课程名称） --> 分数
	**完全函数依赖**:例如分数的确定必须依赖于学号和课程名称缺一不可
	**部分函数依赖**:例如姓名的确定只需要依赖学号和课程中的学号即可
	**传递函数依赖**:例如系主任的确定依赖于系名.而系名的确定需要依赖与学号

---
**主从数据同步(异步复制、全同步复制与半同步复制)**
	[详情](https://www.51cto.com/article/606556.html)
	异步复制:5.7以前主要使用复制
	全同步复制:不常用的同步线程,主库执行完一个事务，所有的从库都执行了该事务才返回给客户端
	半同步复制:5.7以后常用复制,原理是异步复制的基础上,主库在执行完客户端提交的事务后不是立刻返回给客户端,需接收到至少一个slave库反馈的reply后返回客户端(这个延迟最少是一个TCP/IP往返的时间。所以，半同步复制最好在低延时的网络中使用)
**Mysql主从复制延迟问题?**
	**问题:** 由于网络延迟、从数据库负载等原因，从数据库上的数据可能会出现一定的延迟，导致主从数据不一致的情况
	**解决:** 
	1.调整复制线程的参数：例如调整MySQL复制线程的参数"slave_net_timeout"参数来增加从服务器与主服务器之间的网络超时时间,sync_binlog设置为0或者关闭binlog，innodb_flushlog， innodb_flush_log_at_trx_commit等
	2.使用半同步复制:至少接收到一个从节点的reply后再返回客户端
	3.使用多线程复制：MySQL 5.6版本及以上支持多线程复制。可以使用多个线程来进行数据复制，
	4.使用基于时间戳的复制：从服务器会在主服务器上的数据更新后，等待一段时间再进行复制。
	终极:使用读写分离哨兵模式

---
## Mysql触发器
触发器(trigger)的作用和原理
	触发器是SQL server 提供给程序员和数据分析员来保证数据完整性的一种方法，是由事件来触发，
	**作用**:
		1. 触发器可以通过数据库中的相关表进行层叠修改。
		2. 触发器可以强制限制。这些限制比用CHECK约束所定义的更复杂。与CHECK约束不同的是，触发器可以引用其他表中的列。
		3. 加强数据的完整性约束和业务规则等。
	**原理**:
		![[数据库概念_image_1.png]]
触发器分类:
	**1. DML(数据操作语言,Data Manipulation Language)触发器**
	DML触发器是一些附加在特定表或视图上的操作代码，当数据库服务器中发生数据操作语言事件时执行这些操作。SqlServer中的DML触发器有三种：
	- insert触发器:向表中插入数据时被触发;
	- delete触发器：从表中删除数据时被触发;
	- update触发器：修改表中数据时被触发。
	当遇到下列情形时，应考虑使用DML触发器：
	- 通过数据库中的相关表实现级联更改
	- 防止恶意或者错误的insert、update和delete操作，并强制执行check约束定义的限制更为复杂的其他限制。
	- 评估数据修改前后表的状态，并根据该差异才去措施。
	**2. DDL(数据定义语言,Data Definition Language)触发器**
	DDL触发器是当服务器或者数据库中发生数据定义语言(主要是以create,drop,alter开头的语句)事件时被激活使用，使用DDL触发器可以防止对数据架构进行的某些更改或记录数据中的更改或事件操作。
	**3. 登录触发器**
	登录触发器将为响应 LOGIN 事件而激发存储过程。与 SQL Server 实例建立用户会话时将引发此事件。登录触发器将在登录的身份验证阶段完成之后且用户会话实际建立之前激发。因此，来自触发器内部且通常将到达用户的所有消息(例如错误消息和来自 PRINT 语句的消息)会传送到 SQL Server 错误日志。如果身份验证失败，将不激发登录触发器。
触发器执行流程:
	![[数据库概念_image_2.png]]

存储过程与触发器的区别
	触发器与存储过程非常相似，触发器也是SQL语句集，两者唯一的区别是触发器不能用EXECUTE语句调用，
	而是在用户执行Transact-SQL语句时自动触发（激活）执行。触发器是在一个修改了指定表中的数据时执行的存储过程
	。通常通过创建触发器来强制实现不同表中的逻辑相关数据的引用完整性和一致性。由于用户不能绕过触发器，
	所以可以用它来强制实施复杂的业务规则，以确保数据的完整性。触发器不同于存储过程，
	触发器主要是通过事件执行触发而被执行的，而存储过程可以通过存储过程名称名字而直接调用。
	当对某一表进行诸如UPDATE、INSERT、DELETE这些操作时，SQLSERVER就会自动执行触发器所定义的SQL语句，
	从而确保对数据的处理必须符合这些SQL语句所定义的规则。
触发器分为事前触发和事后触发，这两种触发有什么区别。语句级触发和行级触发有何区别。
	事前触发器运行于触发事件发生之前，而事后触发器运行于触发事件发生之后。通常事前触发器可以获取事件之前和新的字段值。语句级触发器可以在语句执行前或后执行，而行级触发在触发器所影响的每一行触发一次。

---
## 其他
**Mysql有关权限的表都有哪几个**
	MySQL服务器通过权限表来控制用户对数据库的访问，权限表存放在mysql数据库里，由mysql_install_db脚本初始化。这些权限表分别user，db，table_priv，columns_priv和host。下面分别介绍一下这些表的结构和内容：
	user权限表：记录允许连接到服务器的用户帐号信息，里面的权限是全局级的。
	db权限表：记录各个帐号在各个数据库上的操作权限。
	table_priv权限表：记录数据表级的操作权限。
	columns_priv权限表：记录数据列级的操作权限。
	host权限表：配合db权限表对给定主机上数据库级操作权限作更细致的控制。这个权限表不受GRANT和REVOKE语句的影响。
数据库操作命令
	创建数据库
	书写格式:
	create database 数据库名 [character set 字符集 collate 字符集校对规则];
	查看数据库
	书写格式
	show databases;
	查看数据库的创建细节
	书写格式
	show create database 数据库名;
	删除数据库
	书写格式
	drop database 数据库名;
	修改数据库
	书写格式
	alter database 数据库名 character set 字符集 collate 校对规则;
	切换数据库
	书写格式
	use 数据库名;
	显示正在使用的数据库
	书写格式
	select database();
对表进行操作命令(增删改查)
	创建表(不带约束)
	create table 表名 (字段名 字段类型(长度)约束,字段名 字段类型(长度) 约束..)[character set 字符集 collate 校对规则];
	查看表
	书写格式
	show tables;
	查看表结构
	书写格式
	desc 表名;
	删除表
	书写格式
	drop table 表名
	修改表
	书写格式
	alter table 表名 add 字段名 字段类型(长度) 约束;
	--添加新的字段
	alter table 表名 change 旧字段名 新字段名 字段类型(长度) 约束;--修改字段名
	alter table 表名 modify 字段名 字段类型(长度) 约束;
	--修改字段类型和约束
	alter table 表明 drop 字段名 ;--删除此字段
	rename table 旧表名 to 新表名;
	--修改表名
	alter table 表名 character set 字符集;
	--修改表的字符集类型
	插入部分字段
	insert into 表名(字段名1,字段名2,字段名3...)values(值1,值2,值3...);
	插入全部字段
	insert into 表名 values(值1,值2,值3..);
	修改记录
	值直接覆盖
	update 表名 set 字段名 = 值 , 字段名 = 值(where 条件)
	在原有基础上修改
	update 表名 set 字段名 = 字段名[赋值操作符]值, 字段名=值[where条件];
	delete删除法
	delete from 表名 (where条件)
	//如果不加条件则是删除整个表内数据
	truncate table 表名; 属于逐条删除属于dml
	//truncate 与dalete不同是直接删除表然后重建一个同命名表
	属于ddl
	select [distinct] * 或[列名,列名...]from 表名;
	distinct去除查询记录中的重复值
	*为所有字段返回
	DML能进行事物管理
	DDL不能
	查询记录之执行运算
	不起别名方式
	select 表达式 from 表;
	起别名方式
	select 列名 as 别名 ,列名 as 别名 from 表名
	--其中as可以省略
	查询记录并过滤条件
	select *, 列名 from 表名 where 条件;
	常用条件符号> ,< ,>=,<=,=,<>
	in:一组值
	like:模糊查询
	使用占位符:_代表1个空位%代表后面有1到无数空位
	例如:张_可以代表张2,而张%可以代表张22222222
	between, and, or, not也是常用格式
	查询记录并排序
	select *from 表名 where 条件 order by 列名 asc/desc. 列名asc/desc;
	asc代表升序
	desc带表降序
	环境搭建
	select * from 表名 where 条件 group by 列名;
	//这样条件内的就会归为一个group内
	但是聚集函数条件得用having
	select * from 表名 where 条件 group by 列名 having 聚集函数 order by 列名 asc/desc;
多表关系设计
	多表设计对一(两种方案)
	1.唯一外键对应,在一张表中建立一个字段,使用unique约束,并作为外键指向领一张表的主键
	2.主键对应:将一张表中的主键作为外键约束指向;另一张表的主键
	多表设计一对多
	需要在多的一方添加一个字段(主键什么类型他就什么类型),并将添加的这个字段作为外键约束(外键在多的一方)指向一的一方的主键
	多表设计多对多
	创建一个中间表(作为多的一方),中间表中需要有两个字段,分别作为外键指向多对多双方的主键
	外键约束的主要目的及作用
	使需要关联的数据产生关联,防止脏数据的存在,需要使用外键
	alter table 多的一方表 add foreign key(外键名) references
	一的一方的表(主键名);
可视化工具SQLyog
	SQLyog 是一个快速而简洁的图形化管理MYSQL数据库的具，它能够在任何地点有效地管理你的数据库，由业界著名的Webyog公司出品。
	备份语法:mysqldump-u root-p 数据库名>路径\备份文件名.sql
	还原语法:mysql-u root-p 数据库名 < 备份文件名.sql
多表查询
	**多表查询之内连接**
	select * from 表名A , 表名B where 条件;
	select * from 表名A inner join 表B on 条件;
	**多表查询之外连接**
	select * fom 表A left outer join 表B on 条件
	(打印左边表A和两表交集)
	select * from 表A right outer join 表B on 条件
	(打印右边表B和两表交集)
	**多表查询之子查询**
	例如:
	select * from 表A where 条件 >(子查询语句);
	any 和all的使用
	any:任意一个
	all:所有
	子查询不同情况
	1.单行单列
	2.多行单列
	3.多行多列
	例:
	select * from dept t1 , employee t2 where t1.did = t2.dno
	and age > 20;
	做法2:
	select * from dept t1 , (select * from employee where age >20 ) t2 where t1.did = t2.dno
	(这是把子表格当做新的t2来比较交集)
如果要在dos命令窗口输入中文
	dos窗口的输入字符集是gbk(这是很难修改的),而sql客户端的默认字符集是utf8(这是容易修改的)
	临时解决方案
	set names gbk;
	永久解决方案
	找到mysql的安装路径：my.ini文件.设置default-character-set=gbk重启服务重新打开dos窗口
如果创建表需要带约束
	单表约束
	为了保证数据的完整性
	分类
	主键约束:primary key 可以唯一确定表中一条记录的字段(非空唯一).主键是整型可以使用auto_increment
	唯一约束:unique.创建表中这个字段的时候,这个字段不允许出现重复的值
	非空约束:not null 代表创建这个表中的这个字段的时候,不可以向这个字段插入空值
超键、候选键、主键、外键分别是什么？
	超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。
	候选键(候选码)：是最小超键，即没有冗余元素的超键。
	主键(主码)：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。
	外键：在一个表中存在的另一个表的主键称此表的外键。
	候选码和主码：例子：邮寄地址（城市名，街道名，邮政编码，单位名，收件人）
	它有两个候选键:{城市名，街道名} 和 {街道名，邮政编码}
	如果我选取{城市名，街道名}作为唯一标识实体的属性，那么{城市名，街道名} 就是主码(主键)
数据库运行于哪种状态下可以防止数据的丢失？
	在archivelog mode(归档模式)只要其归档日志文件不丢失，就可以有效地防止数据丢失。
数据表损坏的修复方式有哪些？
	1.使用 myisamchk 来修复，具体步骤：
		  1）修复前将mysql服务停止。
		  2）打开命令行方式，然后进入到mysql的/bin目录。
		  3）执行myisamchk –recover 数据库所在路径/*.MYI
	2.使用repair table 或者 OPTIMIZE table命令来修复，REPAIR TABLE table_name 修复表 OPTIMIZE TABLE table_name 优化表 REPAIR TABLE 用于修复被破坏的表。
		OPTIMIZE TABLE 用于回收闲置的数据库空间，当表上的数据行被删除时，所占据的磁盘空间并没有立即被回收，使用了OPTIMIZE TABLE命令后这些空间将被回收，并且对磁盘上的数据行进行重排（注意：是磁盘上，而非数据库）

存储过程和函数的区别
	存储过程是用户定义的一系列sql语句的集合，涉及特定表或其它对象的任务，用户可以调用存储过程，而函数通常是数据库已定义的方法，它接收参数并返回某种类型的值并且不涉及特定用户表。
	-
	另外，存储过程和函数还有以下几个区别：
	1）存储过程一般是作为一个独立的部分来执行的，而函数可以作为查询语句的一个部分来调用。由于函数可以返回一个对象，因此它可以在查询语句中位于From关键字的后面。
	2）一般而言，存储过程实现的功能较为复杂，而函数实现的功能针对性较强。
	3）函数需要用括号包住输入的参数，且只能返回一个值或表对象，而存储过程可以返回多个参数
	4）函数可以嵌入在SQL中使用，可以在SELECT中调用，存储过程不行。
	5）函数不能直接操作实体表，只能操作内建表。
	6）存储过程在创建时即在服务器上进行了编译，其执行速度比函数快。
游标:
	（关系数据库中的操作会对整个行集起作用。由 SELECT 语句返回的行集包括满足该语句的 WHERE 子句中条件的所有行。这种由语句返回的完整行集称为结果集。应用程序，特别是交互式联机应用程序，并不总能将整个结果集作为一个单元来有效地处理。这些应用程序需要一种机制以便每次处理一行或一部分行。游标就是提供这种机制的对结果集的一种扩展。
游标的作用？如何知道游标已经到了最后？
	游标用于定位结果集的行，通过判断全局变量@@FETCH_STATUS可以判断是否到了最后，通常此变量不等于0表示出错或到了最后。
游标的特点是：
	允许定位在结果集的特定行。
	从结果集的当前位置检索一行或一部分行。
	支持对结果集中当前位置的行进行数据修改。
	为由其他用户对显示在结果集中的数据库数据所做的更改提供不同级别的可见性支持。
	提供脚本、存储过程和触发器中用于访问结果集中的数据的 Transact-SQL 语句
	在从游标中提取信息后，可以通过判断@@FETCH_STATUS 的值来判断是否到了最后。当@@FETCH_STATUS为0的时候，说明提取是成功的，否则就可以认为到了最后。）
什么是视图?,视图的使用场景有哪些?
	数据库视图概念和语句
		概念:就是封装了复杂查询语句的伪表
		视图语句体:
		create view 视图名称 as sql查询语句
		视图语句使用:
		select * from 视图名
		使用视图代替了大串sql语句来使用
	(1）视图是一种虚表
	（2）视图建立在已有表的基础上, 视图赖以建立的这些表称为基表
	（3）向视图提供数据内容的语句为 SELECT 语句,可以将视图理解为存储起来的 SELECT 语句
	（4）视图向用户提供基表数据的另一种表现形式
	（5）视图没有存储真正的数据，真正的数据是存储在基表中
	（6）程序员虽操作的是视图，但最终视图还会转成操作基表
	（7）一个基表可以有0个或多个视图
	视图可以进行一些单表操作,并且会改变原本引用表中的数据,但是不能进行很多多表操作
	视图可以将查询出来的数据进行封装。。。那么我们在使用的时候就会变得非常方便…
	值得注意的是：使用视图可以让我们专注与逻辑，但不提高查询效率
三种类型的删除的差别
	drop table
		1)属于DDL(Data Definition Language)数据定义语言
		2)不可回滚
		3)不可带where
		4)表内容和结构删除
		5)删除速度快
	truncate table
		1)属于DDL(Data Definition Language)数据定义语言
		2)不可回滚
		3)不可带where
		4)表内容删除
		5)删除速度快
	delete from
		1)属于DML(Data Manipulation Language))数据操纵语言
		2)可回滚
		3)可带where
		4)表结构在，表内容要看where执行的情况
		5)删除速度慢,需要逐行删除
	不再需要一张表的时候，用drop
	想删除部分数据行时候，用delete，并且带上where子句
	保留表而删除所有数据的时候用truncate
















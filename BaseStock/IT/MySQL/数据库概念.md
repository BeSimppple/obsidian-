**什么是数据库:**
	数据库就是一个文件系统,但是这个文件访问需要通过标准SQL语句
**数据库分类**
	关系型数据库
		MYSQL, SQLServer, Oracle ,DB2, SyBase, SQLite
	非关系型数据库
		redis
		mongodb
MySQL内部存储结构
	一个软件对应一个数据库,在数据库内部可以存在多张表:
	一个实体类对应一张表.表中可以有多条记录的
	.一般情况下：一类的实例对应一条记录
什么是SQL?
	SQL:Structured Query Language.结构化查询语言
SQL分类
	DDL(Data Definition Language)
	数据定义语言
	DML(Data Manipulation Language)
	数据处理语言
	DQL(Data Query Language)
	数据查询语言
	DCL(Data Control Language)
	数据控制语言
MySQL的常用类型(对应Java类型)
	java类型--- MySQL类型
	String ---CHAR/VARCHAR
	byte ---TINYINT
	short ---SMALLINT
	int ---INT
	long ---BIGINT
	float ---FLOAT
	double ---DOUBLE
	boolean ---BIT
	date ---DATE/TIME/DATETIME/TIMESTAMP
## 事务
概念:
	一条或者多条SQL语句组成一个执行单元
	特点:同时成功或同时失败相互依赖成一整体
	如果某条sql语句执行错误或失败你那么整个单元就会回滚到事务最初状态,如果都执行成功,则事务就顺利进行.
事务管理语法:
	start transaction //开启事务,开启后数据都是临时的,需要回滚或者提交才生效
	rollback //将数据回滚到开启事务之前,然后结束事务
	commit //提交数据到数据库,然后结束事务 提交后才是真的数据"持久化"也是真的写入数据库
事务的提交方式:
	自动提交:由系统自动提交
	手动提交:由程序员代码提交
	select @@AUTOCOMMIT; 返回值:1或0
	1代表自动提交,0代表手动提交
	set @@AUTOCOMMIT =数字;
**Mysql中事务实现原理:**
	MySQL中的事务是通过ACID（原子性、一致性、隔离性和持久性）属性来保证数据的完整性和一致性的
	原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql
	一致性：由其他三大特性共同保证，是事务的目的
	隔离性：由MVCC(多版本并发控制)保证
	持久性：由redo log日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复
**事务的四大特征**
	**原子性（atomicity）**
	是不可分割的最小操作单位，要么同时成功，要么同时失败。
	**持久性（consistency）**
	当事务提交或回滚后，数据库会持久化的保存数据。
	**隔离性（isolcation）**
	多个事务之间。相互独立。
	事实上事务之间是存在一定的影响的，需要理解隔离级别。
	**一致性（durability）**
	事务操作前后，数据总量不变
	比如：转账前后，两个用户的金额总数不变。
**事务的隔离级别**
	**概念:** 多个事务之间隔离的,相互独立的,但是如果多个事务并发操作同一批数据,则会引发一些问题,设置不同的隔离级别就可以解决这些问题.
	**隔离级别**
	1.读未提交 read uncommitted
	//可以读到未提交的数据
	存在问题:1.脏读2.不可重复读3.幻读
	2.读已提交 read committed
	//存在不可重复读,因为每次读取数据不一样
	存在问题:1.不可重复读2.幻读
	3.可重复读 repeatable read
	//存在幻读问题
	存在问题:1.幻读
	4.串行化 serializable
	//线程安全,速度极慢一般不用
	不存在问题
脏读
	是指在一个事务处理过程中读取了另一个未提交的事务中的数据 , 导致两次查询结果不一致
不可重复读(mysql隔离级别:默认不可重复读)
	是指在一个事务处理过程中读取了另一个事务中修改并已提交的数据, 导致两次查询结果不一致
	(读取数据的一方 被写入的那方改变了一次的读取数据结果
	写入开启事务同时读取开始事务
	此时写入临时数据,读取事务数据不改变
	此时提交数据成"持久性"数据,读取事务数据被改变
	在一次读取中事务还未提交时数据 读取到的数据不应该被改变
	)
幻读
	select 某记录是否存在，不存在，准备插入此记录，但执行 insert 时发现此记录已存在，无法插入。或不存在执行delete删除，却发现删除成功
	(搜索记录显示不存在,而插入时却显示已经存在)
	(可以用多线程理解,A事务处理时准备插入这个记录但是还未提交,B检索到没有这个数据也准备插入并提交,
	但是此时A完成事务提交,最后B报错存在此条记录)
## 数据库设计范式:
第一范式（1NF）、第二范式（2NF）、第三范式（3NF）、巴斯-科德范式（BCNF）、第四范式(4NF）和第五范式（5NF，又称完美范式）。
一般达到第三范式即可-[图解](https://www.boxuegu.com/news/4803.html)
第一范式（1NF）：
	每一列都是不可分割的原子数据项
第二范式（2NF）：
	在1NF的基础上，非码属性必须完全依赖于主码
	（在1NF基础上消除非码属性对主码的部分函数依赖）
	让不是绝对函数依赖的另外建立一张表形成联系
第三范式（3NF）：
	在2NF基础上，消除传递依赖
	第三范式为了让数据更好修改,而不会成为脏数据
码:
	如果在一张表中，一个属性或属性组，被其他所有属性所完全函数依赖，则称这个属性(属性组)为该表的码 例如：该表中码设置为（学号，课程名称）
函数依赖：
	A-->B,如果通过A属性(属性组)的值，可以确定唯一B属性的值。则称B依赖于A 例如：学号-->姓名。 （学号，课程名称） --> 分数
	**完全函数依赖**:例如分数的确定必须依赖于学号和课程名称缺一不可
	**部分函数依赖**:例如姓名的确定只需要依赖学号和课程中的学号即可
	**传递函数依赖**:例如系主任的确定依赖于系名.而系名的确定需要依赖与学号
## 其他
数据库操作命令
	创建数据库
	书写格式:
	create database 数据库名 [character set 字符集 collate 字符集校对规则];
	查看数据库
	书写格式
	show databases;
	查看数据库的创建细节
	书写格式
	show create database 数据库名;
	删除数据库
	书写格式
	drop database 数据库名;
	修改数据库
	书写格式
	alter database 数据库名 character set 字符集 collate 校对规则;
	切换数据库
	书写格式
	use 数据库名;
	显示正在使用的数据库
	书写格式
	select database();
对表进行操作命令(增删改查)
	创建表(不带约束)
	create table 表名 (字段名 字段类型(长度)约束,字段名 字段类型(长度) 约束..)[character set 字符集 collate 校对规则];
	查看表
	书写格式
	show tables;
	查看表结构
	书写格式
	desc 表名;
	删除表
	书写格式
	drop table 表名
	修改表
	书写格式
	alter table 表名 add 字段名 字段类型(长度) 约束;
	--添加新的字段
	alter table 表名 change 旧字段名 新字段名 字段类型(长度) 约束;--修改字段名
	alter table 表名 modify 字段名 字段类型(长度) 约束;
	--修改字段类型和约束
	alter table 表明 drop 字段名 ;--删除此字段
	rename table 旧表名 to 新表名;
	--修改表名
	alter table 表名 character set 字符集;
	--修改表的字符集类型
	插入部分字段
	insert into 表名(字段名1,字段名2,字段名3...)values(值1,值2,值3...);
	插入全部字段
	insert into 表名 values(值1,值2,值3..);
	修改记录
	值直接覆盖
	update 表名 set 字段名 = 值 , 字段名 = 值(where 条件)
	在原有基础上修改
	update 表名 set 字段名 = 字段名[赋值操作符]值, 字段名=值[where条件];
	delete删除法
	delete from 表名 (where条件)
	//如果不加条件则是删除整个表内数据
	truncate table 表名; 属于逐条删除属于dml
	//truncate 与dalete不同是直接删除表然后重建一个同命名表
	属于ddl
	select [distinct] * 或[列名,列名...]from 表名;
	distinct去除查询记录中的重复值
	*为所有字段返回
	DML能进行事物管理
	DDL不能
	查询记录之执行运算
	不起别名方式
	select 表达式 from 表;
	起别名方式
	select 列名 as 别名 ,列名 as 别名 from 表名
	--其中as可以省略
	查询记录并过滤条件
	select *, 列名 from 表名 where 条件;
	常用条件符号> ,< ,>=,<=,=,<>
	in:一组值
	like:模糊查询
	使用占位符:_代表1个空位%代表后面有1到无数空位
	例如:张_可以代表张2,而张%可以代表张22222222
	between, and, or, not也是常用格式
	查询记录并排序
	select *from 表名 where 条件 order by 列名 asc/desc. 列名asc/desc;
	asc代表升序
	desc带表降序
环境搭建
select * from 表名 where 条件 group by 列名;
//这样条件内的就会归为一个group内
但是聚集函数条件得用having
select * from 表名 where 条件 group by 列名 having 聚集函数 order by 列名 asc/desc;

多表关系设计
多表设计对一(两种方案)
1.唯一外键对应,在一张表中建立一个字段,使用unique约束,并作为外键指向领一张表的主键
2.主键对应:将一张表中的主键作为外键约束指向;另一张表的主键
多表设计一对多
需要在多的一方添加一个字段(主键什么类型他就什么类型),并将添加的这个字段作为外键约束(外键在多的一方)指向一的一方的主键
多表设计多对多
创建一个中间表(作为多的一方),中间表中需要有两个字段,分别作为外键指向多对多双方的主键
外键约束的主要目的及作用
使需要关联的数据产生关联,防止脏数据的存在,需要使用外键
alter table 多的一方表 add foreign key(外键名) references
一的一方的表(主键名);
可视化工具SQLyog
	SQLyog 是一个快速而简洁的图形化管理MYSQL数据库的具，它能够在任何地点有效地管理你的数据库，由业界著名的Webyog公司出品。
	备份语法:mysqldump-u root-p 数据库名>路径\备份文件名.sql
	还原语法:mysql-u root-p 数据库名 < 备份文件名.sql
多表查询
	**多表查询之内连接**
	select * from 表名A , 表名B where 条件;
	select * from 表名A inner join 表B on 条件;
	**多表查询之外连接**
	select * fom 表A left outer join 表B on 条件
	(打印左边表A和两表交集)
	select * from 表A right outer join 表B on 条件
	(打印右边表B和两表交集)
	**多表查询之子查询**
	例如:
	select * from 表A where 条件 >(子查询语句);
	any 和all的使用
	any:任意一个
	all:所有
	子查询不同情况
	1.单行单列
	2.多行单列
	3.多行多列
	例:
	select * from dept t1 , employee t2 where t1.did = t2.dno
	and age > 20;
	做法2:
	select * from dept t1 , (select * from employee where age >20 ) t2 where t1.did = t2.dno
	(这是把子表格当做新的t2来比较交集)
数据库视图
	概念:就是封装了复杂查询语句的伪表
	视图语句体:
	create view 视图名称 as sql查询语句
	视图语句使用:
	select * from 视图名
	使用视图代替了大串sql语句来使用
如果要在dos命令窗口输入中文
	dos窗口的输入字符集是gbk(这是很难修改的),而sql客户端的默认字符集是utf8(这是容易修改的)
	临时解决方案
	set names gbk;
	永久解决方案
	找到mysql的安装路径：my.ini文件.设置default-character-set=gbk重启服务重新打开dos窗口
如果创建表需要带约束
	单表约束
	为了保证数据的完整性
	分类
	主键约束:primary key 可以唯一确定表中一条记录的字段(非空唯一).主键是整型可以使用auto_increment
	唯一约束:unique.创建表中这个字段的时候,这个字段不允许出现重复的值
	非空约束:not null 代表创建这个表中的这个字段的时候,不可以向这个字段插入空值
Mysql
![[数据库优化(相关概念)_image_1.jpg|400]]
## 索引(sql优化核心)
作用
	排序好的数据结构可以提供更快速的查询
	索引就像新华字典的字,有了索引则会在查询的时候快很多,但是创建索引要搜寻所有数据,所以创建会慢,增删改的时候会创建和变动索引,所以一般使用在多查询的场景,
缺点：
	1. 创建索引和维护索引要耗费时间，这种时间随着数据量的增加而增加。
	2. 索引需要占物理空间，除了数据表占数据空间之外，每一个索引还要占一定的物理空
	间，如果要建立聚簇索引，那么需要的空间就会更大。
	3. 当对表中的数据进行增加、删除和修改的时候，索引也要动态的维护，这样就降低了数据的维护速度。
添加索引情况
	适合加索引的情况：主键自动添加索引，频繁作为查询条件的字段
	不适合加索引的情况：表记录少、频繁更新的字段、区分度低的字段
**两种SQL数据库差别**
	主要差别:Myisam与innodb是表级别的不是数据库级别的执行引擎
	次要差别:MyISAM不支持主外键和事务,表空间较小性能更强
	InnoDB中不保存表的具体行数，而MYISAM对是单独存起来的。也就是说select count(*) from table 时，MYISAM会比InnoDB快的多。
	![[数据库优化(相关概念)_image_2.jpg]]
## 慢SQL优化:
慢查询日志:   MySQL的慢查询日志是记录在MySQL中响应时间超过long_query_time阀值的的SQL，并记录到慢查询日志中。
**如何查看和调用慢查询日志：**
	在mysql中输入set global slow_query_log=1;
	查看慢查询是否生效show variables like '%slow_query_log%';
	**永久生效则需修改my.cnf文件 slow_query_log=1;然后设置日志存放地址slow_query_log_file=/tmp/mysql_slow.log**
	log_output默认是以file文件形式（set global log_output='TABLE'也可以修改成以表的形式存到数据库中）
	默认开启慢查询日之后long_query_time=10代表sql查询超过10s会进入日志，可以到my.cnf中修改
**SQL执行计划详情查询（分析语句底层属性）**
	explain：查看sql执行计划,分析sql执行性能
	语法：explain+sql
	主要属性:
	id[重要]
		-   id列结合table列，可以查看表的加载顺序
		-   id相同，按table列从上到下顺序加载
		-   id列不同，id值越大越先被加载
	select_type
		查看查询类型
		-- SIMPLE :简单的sql查询
		-- PRIMAY：查询中包含任何复杂的子查询，最外层查询标记为PRIMARY（主要查询）
		--SUBQUERY:select 或者where中包含子查询（则里面的子查询被标记为SUBQUERY）
		--DERIVED:临时表
		--UNION:UNION后面的查询标记为UNION
		--UNION RESULT:使用UNION结合查询的结果标记为UNION RESULT
	type{重要}
		**通过什么方式获取数据**
		效率从好到次：**System>Const>eq_ref>ref>range>index>all**
		一个查询如果达到range或者ref表示这条sql无需优化
		如果是ALL在搜索量比较大的情况下,必须优化
		--system:从系统库mysql的系统表proxies_priv里查询数据,不需要IO在mysql启动的时候就有了
		-- const：主键或唯一索引查询，查出的结果为单条记录
		-- eq_ref 多表连接中被驱动表（右边的表）的连接列上有primary key或者unique index的检索 --用小表的高效索引去驱动大表（小表同时数据量小更快先查出小表数据然后用更少的数据去匹配大表）
		--ref: 非主键非唯一索引等值扫描（非唯一代表可能索引附近有相同值）
		--range 范围查询 between、in、>、>=、<、<=、or
		--index：全索引扫描
		--all:全硬盘扫描、没用上索引
	possible_keys{重要}
		理论上会用到哪些索引
	keys{重要}
		实际上用到的索引
	key_len
		key_len 用于表示本次查询中，所选择的索引长度有多少字节，通常我们可借此判断联合索引有多少列被选择了。
		结论：值越大 ，效率最好（每种类型int，varchar类型索引大小可去网上查）
	rows
		当前查询，扫描了多少行数，也是性能评估的重要依据
		rows值越大效率越低
	extra{重要}
		Using where（表示使用了wherr作为筛选条件）
		Using index（表示使用了索引或覆盖索引避免了全局扫描）
		Using filesort（通常出现在order by，当试图对一个不是索引的字段进行排序时，mysql就会自动对该字段进行排序，这个过程就称为“文件排序”）
		Using temporary（表示在查询过程中产生了临时表用于保存中间结果。mysql在对查询结果进行排序时会使用临时表，常见于group by）
		最好保证都有useing index代表有用上索引
如何配置慢查询到Druid网页控制台中:
	数据池监控:druid（数据库连接池）监控数据连接池方便查看慢查询日志
	通过durid链接java项目，首先在web.xml中加入相关配置和过滤器账号密码
	![[tmp1683168390767_数据库优化(相关概念)_image_2.jpg]]
	然后创建applicationContext-dao。xml中加入druid的配置
	![[tmp1683168390844_数据库优化(相关概念)_image_3.jpg]]
	配置一个代理过滤器
	![[tmp1683168390903_数据库优化(相关概念)_image_4.jpg]]
	添加log4j打日志功能
	-
	resources下面新建log4j.properties
	![[数据库优化(相关概念)_image_3.jpg]]
	最后pom。xml加入loig4j依赖
	-
	最后访问durid的地址是项目地址/druid/index.html（localhost：8081/druid/index.html）
	-
	账号密码均为项目中自己设置的，然后再sql监控中查看具体信息
## 索引的数据结构
**hash表**
	优点：等值查找块
	缺点：不适合范围查询
**二叉搜索树**
	特点:效果相对于普通索引明显,但是深度容易太深
	缺点：极端情况下(数据由小到大排列,或大到小)二叉查找树会退变成链表
**红黑树（平衡二叉树）**
	与二叉树的差别:会自动平衡树的数据结构(尽量让中位数在中间),不会发生特别极端情况,
	缺点：当数据量达到上千万级别的时候，树的深度太深，查询效率还是慢
**B(balance)-Tree**
	特点:增加了一行宽度的范围,减少了树的深度
	(系统从磁盘读取数据到内存时是以磁盘块（block）为基本单位的，位于同一个磁盘块中的数据会被一次性读取出来，而不是需要什么取什么。)
	![[数据库优化(1)_image_7.jpg]]
	B-Tree的缺点：每个非叶子节点中不仅包含key，还有data值。而每一个页的存储空间是有限的，如果data数据较大时将会导致每个节点（即一个页）能存储的key的数量很小，当存储的数据量很大时同样会导致B-Tree的深度较大，增大查询时的磁盘I/O次数，进而影响查询效率。
**B+Tree**
	B+Tree是在B-Tree基础上的一种优化，使其更适合实现外存储索引结构，InnoDB存储引擎就是用B+Tree实现其索引结构。
	![[数据库优化(1)_image_8.jpg]]
B+Tree相对于B-Tree有几点不同：
1:非叶子节点只存key信息,从而达到压缩层数的效果
2:所有叶子节点之间都有一个链指针。
3:数据记录都存放在叶子节点中。

InnoDB存储引擎中页的大小为16KB，一般表的主键类型为INT（占用4个字节）或BIGINT（占用8个字节），指针类型也一般为4或8个字节，也就是说一个页（B+Tree中的一个节点）中大概存储16KB/(8B+8B)=1K个键值,一个深度为3的B+Tree索引可以维护1000*1000 * 1000 = 10亿条记录
## 索引类型
(对于经常更新的,或者区分度不大的例如:男女 不需要建立索引)
**聚集索引(Clustered index)**
	默认系统按照主键创建聚集索引，如果没有定义主键,那么inndb会选择一个 唯一 非空 的值做聚集索引
	聚集索引的叶子节点存放是一整行的信息。 聚集索引一个表只能有一个，而非聚集索引一个表可以存在多个。 聚集索引存储记录是物理上连续存在，而非聚集索引是逻辑上的连续，物理存储并不连续。 聚集索引查询数据速度快，插入数据速度慢(为了保证表中记录的物理和索引顺序一致，在记录插入的时候，会对数据页重新排序);非聚集索引反之。 聚集索引范围查询快。
**非聚集索引索引（Secondary index）**
	辅助索引、二级索引、非主键索引,,非聚集索引描述的是一个意思
	不是主键的索引,查询数据的时候不是直接找到挂载的数据,而是找到下面的主键,再通过主键索引找到挂载数据
	-
	叶子节点中并不包含行记录的全部数据。叶子节点除了包含键值以外，叶子节点包含了一个书签(主键的数据行地址) 然后通过该主键再到聚集索引获取行数据
	(非聚集索引制定了表中记录的逻辑顺序，但是记录的物理和索引不一定一致,在逻辑上数据是按顺序排存放的，但是物理上在真实的存储器中是散列存放的。同时适用的情况就在于分组，大数目的不同值，频繁更新的列中，这些情况即不适合聚集索引。)
**联合索引（Covering index）**
	如果一个索引包含了（或覆盖了）满足查询语句中字段与条件的数据就叫做覆盖索引。
	联合索引比建立多个单例索引更加节省磁盘空间
	比如说你要查名字和年龄,先前你建立了一个名字,年龄和位置的联合索引, 这时候就没必要通过主键查到所有挂的数据再搜索,而是可以通过联合索引查找后在查看联合索引后的内容 但是一定要注意排序顺序,只有第一个是全局排序,后面的是相对排序
	  ![[数据库优化(相关概念)_image_4.jpg]]

**sql优化的10个索引法则**
	1.最左前缀法则(创建联合索引只有最左边的会是全局排序,其他都是局部排序索引列不能运算:否则索引将会失效,最好将运算用其他表示优化索引列类型自动转换:)
	2.索引列不能参与运算
	3.索引列类型自动转换(尽量避免)
	4.!=索引失效(尽量不使用)
	5.非空判断索引失效(尽量不使用)
	6.模糊查询(尽量不使用)
	7.or(尽量不使用)
	8.order by要遵循最左前缀法则
	9.varchar类型加引号(要加引号)
	10.高效索引先使用(减小范围后使用相对低效索引整体会更快)
**Mysql常用关键字**
	**select**:搜索
	**union**:联合表(两张表字段必须相同)
	**left join**:左外链接联合表(表字段不需要相同,但必须有关联字段)
	**check**:insert时设置条件字段
	**order by**:排序字段
	**group by**:分组字段
	**count**:计数字段(写在对应字段前)
	**distinct**:去重字段(写在表前)
	**limit**:范围字段
	**as**:取别名
	**like**:配合%符号进行模糊查询
	**between**:范围字段
	**sedc**:显示结构
	**sun**:加法计数字段
	**avarge**:平均计数字段
	**having**:确定是否包含
	**partition by**:分组聚合函数-类似goupy by
**Mysql中常见符号**
	<> 代表不等于
	%模糊查询通配符表示一个或多个
	\_模糊查询通配符表示一个
	\\表示转义符
**Mysql中常用函数**
	[常用函数](https://developer.aliyun.com/article/740242)
	concat函数:拼接字符
	ifnull函数:判断字段是否有值，有值则显示本身的值，为null则显示null或者自己指定的字符或者数值。
	isnull函数：判断字段是否有值，有值返回0，为null返回1（类似boolean类型，0为true，1为false）
	upper/lower函数：将字符转换为大写/小写。
	length函数：返回字符的字节长度（在字符编码为UTF-8时，一个汉字返回3个字节。其它字符编码集中，一个汉字返回2个字节）
	date_format函数：将指定的日期转换为字符
	now函数:返回当前时间
	case when表达式：当XXX则XX
	replace替换函数:  替换指定字符
	trim函数：去除字符首尾的空格。
	substr函数：截取字符。
	数学函数:
		ABS(x)         --返回x的绝对值
		BIN(x)         --返回x的二进制（OCT返回八进制，HEX返回十六进制）
		CEILING(x)     --返回大于x的最小整数值
		EXP(x)         --返回值e（自然对数的底）的x次方
		FLOOR(x)       --返回小于x的最大整数值
		GREATEST(x1,x2,...,xn)--返回集合中最大的值
		LEAST(x1,x2,...,xn)    --返回集合中最小的值
		LN(x)           --返回x的自然对数
		LOG(x,y)        --返回x的以y为底的对数
		MOD(x,y)        --返回x/y的模（余数）
		PI()            --返回pi的值（圆周率）
		RAND()          --返回０到１内的随机值,可以通过提供一个参数(种子)使RAND()随机数生成器生成一个指定的值。
		ROUND(x,y)      --返回参数x的四舍五入的有y位小数的值
		SIGN(x)         --返回代表数字x的符号的值
		SQRT(x)         --返回一个数的平方根
			TRUNCATE(x,y)   --返回数字x截短为y位小数的结果
**Mysql关键字执行顺序**
	 （8）SELECT（9）DISTINCT <select_list>
	 （1）FROM <left_table>
	 （3）<join_type> JOIN <right_table>
	 （2）ON <join_condition>
	 （4）WHERE <where_condition>
	（5）GROUP BY <grout_by_list>
	 （6）WITH {CUTE|ROLLUP}
	 （7）HAVING <having_condition>
	 （10）ORDER BY <order_by_list>
	（11）LIMIT <limit_number>
	正序排序:
	1.  from 
	2.  on 
	3.  join 
	4.  where 
	5.  group by(开始使用select中的别名，后面的语句中都可以使用)
	6.   avg,sum.... 
	7.  having 
	8.  select 
	9.  distinct 
	10.  order by
	11.  limit
——————————————————————————————————
防止SQL注入，需要注意以下几个要点：
	1.永远不要信任用户的输入。对用户的输入进行校验，可以通过正则表达式，或限制长度；对单引号和双"-"进行转换等。
	2.永远不要使用动态拼装sql，可以使用参数化的sql或者直接使用存储过程进行数据查询存取。
	3.永远不要使用管理员权限的数据库连接，为每个应用使用单独的权限有限的数据库连接。
	4.不要把机密信息直接存放，加密或者hash掉密码和敏感的信息。
	5.应用的异常信息应该给出尽可能少的提示，最好使用自定义的错误信息对原始错误信息进行包装
	6.sql注入的检测方法一般采取辅助软件或网站平台来检测，软件一般采用sql注入检测工具jsky，网站平台就有亿思网站安全平台检测工具。MDCSOFT SCAN等。采用MDCSOFT-IPS可以有效的防御SQL注入，XSS攻击等。
什么是sql批处理?
	就是批量处理同类型sql(insert,delete等)
	**显示批处理**
	INSERT INTO Orders (OrderID, CustID, OpenDate, SalesPerson, Status) VALUES (2002, 1001, {fn CURDATE()}, 'Garcia', 'OPEN'); INSERT INTO Lines (OrderID, Line, PartID, Quantity) VALUES (2002, 1, 1234, 10); INSERT INTO Lines (OrderID, Line, PartID, Quantity) VALUES (2002, 2, 987, 8); INSERT INTO Lines (OrderID, Line, PartID, Quantity) VALUES (2002, 3, 566, 17); INSERT INTO Lines (OrderID, Line, PartID, Quantity) VALUES (2002, 4, 412, 500)
	**面向过程批处理(sql server语句)**
	CREATE PROCEDURE GetCustInfo (@CustomerID INT) AS SELECT * FROM Customers WHERE CustID = @CustomerID SELECT OrderID FROM Orders WHERE CustID = @CustomerID AND Status = 'OPEN'
	CREATE PROCEDURE 语句本身不是一批SQL语句。 但是，它创建的过程是一批SQL语句。 没有分号分隔两个 SELECT 语句，因为 CREATE PROCEDURE 语句特定于SQL Server，SQL Server不需要分号来分隔 CREATE PROCEDURE 语句中的多个语句。
MySQL整个查询的过程
	1.  客户端先发送查询语句给服务器
	2.  服务器检查缓存，如果存在则返回
	3.  进行sql解析，生成解析树，再预处理，生成第二个解析树，最后再经过优化器，生成真正的执行计划
	4.  根据执行计划，调用存储引擎的API来执行查询
	5.  将结果返回给客户端。
Mysql内连接、左连接、右连接的区别
	内连接取量表交集部分，左连接取左表全部右表匹部分，右连接取右表全部坐表匹部分
如何设计数据库？
	简易分析:
	（1）抽取实体，如用户信息，商品信息，评论
	-
	（2）分析其中属性，如用户信息：姓名、性别...
	-
	（3）分析表与表之间的关联关系
	-
	然后可以参考三大范式进行设计，设计主键时，主键要尽量小并且定义为自增和不可修改。

MySQL对表名大小写敏感,对字段大小写不敏感,Orcla大小写都不敏感
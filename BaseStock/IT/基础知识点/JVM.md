**JVM内存模型划分**
根据JVM规范，JVM 内存共分为**虚拟机栈**，**堆**，**元空间**，**程序计数器**，**本地方法栈**五个部分。
![[JVM_image_1.jpg|400]]
1.  **程序计数器**：用于线程切换和记录线程执行的位置。
2.  **Java虚拟机栈**：用于存储方法执行时的局部变量、操作数栈、动态链接、方法出口等信息。每个线程都有自己的Java虚拟机栈。
3.  **本地方法栈**：与Java虚拟机栈类似，但是用于执行本地方法（即使用C等语言编写的方法）。
4.  **Java堆**：用于存储对象实例。Java堆是Java虚拟机管理的内存中最大的一块。
5.  **元空间**：用于存储类元数据，包括类的名称、访问修饰符、字段、方法、注解等信息。与永久代不同，元空间不在Java虚拟机堆中，而是在  本地内存中。
6.  **直接内存**：与Java堆类似，但是用于存储NIO（New Input/Output）库的缓冲区等数据。直接内存不是由Java虚拟机管理的，而是   由操作系统管理的。
Java6和6之前，常量池是存放在方法区（永久代）中的。 
Java7，将常量池是存放到了堆中。 
Java8之后，取消了整个永久代区域，取而代之的是元空间
**关于垃圾回收**
**常用垃圾回收算法:**
	1. 标记-清除 （标记所有需要回收的对象，并在标记完成后，统一回收所有被标记的对象。会产生内存碎片化严重，后续可能发生大对象不能找到可利用空间的问题）
	2. 标记-复制 （按内存容量将内存划分为等大小的两块。每次只使用其中一块，当这一块内存满后将尚存活的对象复制到另一块上去，把已使用的内存清掉）
	（简单效率高不容易产生碎片，但是内容空间少一半且对象数量多了后cooping效率不高）
	3. 标记-整理 （结合了以上两个算法，为了避免缺陷而提出。标记阶段和 Mark-Sweep 算法相同，标记后不是清理对象，而是将存活对象移向内存的一端。然后清除端边界外的对象。）
	4. 分代回收 （分代收集法是目前大部分 JVM 所采用的方法，其核心思想是根据对象存活的不同生命周期将内存划分为不同的域，一般情况下将 GC 堆划分为老生代(Tenured/Old Generation)和新生代(Young Generation)。老生代的特点是每次垃圾回收时只有少量对象需要被回收（Mjor GC次数少一般在oom后），新生代的特点是每次垃圾回收时都有大量垃圾需要被回收（minor GC次数多），因此可以根据不同区域选择不同的算法。）
**GC如何判断是否应该被回收**
	这就是所谓的对象存活性判断,常用的方法有两种:
	1.引用计数法;
	2:对象可达性分析.由于引用计数法存在互相引用导致无法进行GC的问题,所以目前JVM虚拟机多使用对象可达性分析算法.
**简单的解释一下分代垃圾回收**
Java 垃圾回收机制最基本的做法是分代回收。内存中的区域被划分成不同的世代，对象根据其存活的时间被保存在对应世代的区域中。一般的实现是划分成3个世代：年轻、年老和永久（java8元空间使用本地内存而不是永久代的虚拟机内存）。内存的分配是发生在年轻世代中的。当一个对象存活时间足够长的时候，它就会被复制到年老世代中。对于不同的世代可以使用不同的垃圾回收算法。进行世代划分的出发点是对应用中对象存活时间进行研究之后得出的统计规律。一般来说，一个应用中的大部分对象的存活时间都很短。比如局部变量的存活时间就只在方法的执行过程中。基于这一点，对于年轻世代的垃圾回收算法就可以很有针对性.
垃圾回收器的选择
按内存大小分：
![[JVM_image_2.png]]
JAVA对象的内存分配
类加载完成后会在java堆中划分区域分配给对象。分配包含两种方式：
指针碰撞：如果Java堆的内存是规整，即所有用过的内存放在一边，而空闲的放在另一边。分配内存时将位于中间的指针指示器向空闲的内存移动一段与对象大小相等的距离，这样便完成分配内存工作。
空闲列表：如果Java堆的内存不是规整的，则需要由虚拟机维护一个列表来记录哪些内存是可用的，这样在分配的时候可以从列表中查询到足够大的内存分配给对象，并在分配后更新列表记录。
选择哪种分配方式是由 Java 堆是否规整来决定的，而 Java 堆是否规整又由所 采用的垃圾收集器是否带有压缩整理功能决定。
那怎么解决内存分配的并发问题呢？
一方面对分配内存空间的行为进行同步处理（采用CAS+失败重试来保证同步）；
另一方面给每个进程在java堆中预分配一小块空间（TLAB，Thread Local Allocation Buffer），对象现在tlab上分配空间而TLAB的分配才需要用到同步锁。
从分区角度看，内存一般在eden区分配，如果空间不够进行一次minor GC，如果还不够则启用担保机制在老年代分配。特别的，对于大对象，直接进入老年代。
访问内存中的对象
目前有两种方式：句柄访问和直接指针。
句柄访问：是指Java堆中划分出一块内存来作为句柄池，引用中存储对象的句柄地址，而句柄中包含了对象实例数据（实例池）与对象类型数据（方法区）各自的具体地址信息。这种方法的优势：引用中存储的是稳定的句柄地址，在对象被移动（垃圾收集时移动对象是非常普遍的行为）时只会改变句柄中的实例数据指针，而引用本身不需要修改。
直接指针：如果使用直接指针访问，引用中存储的直接就是对象地址，那么Java堆对象内部的布局中就必须考虑如何放置访问类型数据的相关信息。优势：速度更快，节省了一次指针定位的时间开销。由于对象的访问在Java中非常频繁，因此这类开销积少成多后也是非常可观的执行成本。HotSpot中采用的就是这种方式。
JVM调优
JVM调优可以考虑在以下几个方面进行：
线程池：解决用户响应时间长的问题
连接池
JVM启动参数：调整各代的内存比例和垃圾回收算法，提高吞吐量
程序算法：改进程序逻辑算法提高性能
GC调优（大部分情况不需要，只需要在最开始配置环境时设置好对应的GC参数）
在GC调优之前，我们需要记住下面的原则：
1.多数的Java应用不需要在服务器上进行GC优化；
2.多数导致GC问题的Java应用，都不是因为我们参数设置错误，而是代码问题；
3.在应用上线之前，先考虑将机器的JVM参数设置到最优（最适合）；
4.减少创建对象的数量；
5.减少使用全局变量和大对象；
6.GC优化是到最后不得已才采用的手段；
7.在实际使用中，分析GC情况优化代码比优化GC参数要多得多；
GC优化的目的有两个：
1.将转移到老年代的对象数量降低到最小；
2.减少full GC的执行时间；
为了达到上面的目的，一般地，你需要做的事情有：
1.减少使用全局变量和大对象；
2.调整新生代的大小到最合适；
3.设置老年代的大小为最合适；
4.选择合适的GC收集器；
什么是STW？
STW: Stop-The-World: 是在垃圾回收算法执⾏过程当中，将JVM内存冻结丶应用程序停顿的⼀种状态。
在STW 状态下，JAVA的所有线程都是停⽌执⾏的 -> GC线程除外
一旦Stop-the-world发生，除了GC所需的线程外，其他线程都将停止工作，中断了的线程直到GC任务结束才继续它们的任务。
STW是不可避免的,垃圾回收算法执⾏一定会出现STW,我们要做的只是减少停顿的时间
GC各种算法优化的重点，就是减少STW(暂停)，同时这也是JVM调优的重点。
什么时候进入STW状态?
可达性分析算法中枚举根节点（GC Roots）会导致所有Java执行线程停顿,进入STW状态
为什么一定要STW停顿的原因?
分析工作必须在一个能确保一致性的快照中进行
一致性指整个分析期间整个执行系统看起来像被冻结在某个时间点上
如果出现分析过程中对象引用关系还在不断变化，则分析结果的准确性无法保证
被STW中断的应用程序线程会在完成GC之后恢复，频繁的中断会让用户感觉卡顿
所以我们要减少STW的发生,也就相当于要想办法降低GC垃圾回收的频率
STW状态和采用哪款GC收集器无关，所有的GC收集器都有这个状态,因为要保证一致性。
但是好的GC收集器可以减少停顿的时间
减少STW(暂停)和降低GC垃圾回收的频率是调优的重点


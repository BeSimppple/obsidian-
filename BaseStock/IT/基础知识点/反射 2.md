反射
01_反射(类的加载概述和加载时机)
A:类的加载概述
当程序要使用某个类时，如果该类还未被加载到内存中，则系统会通过加载，连接，初始化
三步来实现对这个类进行初始化。
1. 加载就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。//class也就是运行时对象
2. 连接
3. 验证 是否有正确的内部结构，并和其他类协调一致
4. 准备 负责为类的静态成员分配内存，并设置默认初始化值
5. 解析 将类的二进制数据中的符号引用替换为直接引用
6. 初始化 就是对变量的初始化
B:加载时机
创建类对象的实例
访问类的静态变量，或者为静态变量赋值

调用类的静态方法

使用反射方式来强制创建某个类或接口对应的java.lang.Class对象

Class.forName("com.mysql.jdbc.Driver");创建了Driver类的运行时对象

初始化某个类的子类

直接使用java.exe命令来运行某个主类

02_反射(类加载器的概述和分类)

A:类加载器的概述

负责将.class文件加载到内存中，并为之生成对应的Class对象。虽然我们不需要关心类加载机制，但是了解这个机制我们就能更好的理解程序的运行。

B:类加载器的分类

Bootstrap ClassLoader 根类加载器

Extension ClassLoader 扩展类加载器

Sysetm ClassLoader 系统类加载器

C:类加载器的作用

Bootstrap ClassLoader 根类加载器

也被称为引导类加载器，负责Java核心类的加载

比如System,String等。在JDK中JRE的lib目录下rt.jar文件中

Extension ClassLoader 扩展类加载器

负责JRE的扩展目录中jar包的加载。

在JDK中JRE的lib目录下ext目录

Sysetm ClassLoader 系统类加载器

负责在JVM启动时加载来自java命令的class文件，以及classpath环境变量所指定的jar

包和类路径

A:反射概述

JAVA反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；

对于任意一个对象，都能够调用它的任意一个方法和属性；

这种动态获取的信息以及动态调用对象的方法的功能称为java语言的反射机制。

  

在原码期间获取Class对象的方法:

class.forName(class全限定类名);

  

在编译期间获得class对象的方法

类名.class;

  

在运行时获得class对象的方法:

new 对象名().getclass();

  

  

要想解剖一个类,必须先要获取到该类的字节码文件对象就是Class对象。

而解剖使用的就是Class类中的方法，所以先要获取到每一个字节码文件对应的Class类型的

对象。

B:三种方式

a:Object类的getClass()方法,判断两个对象是否是同一个字节码文件

b:静态属性class,锁对象

c:Class类中静态方法forName(),读取配置文件

  

反射结合工厂模式

工厂案例,就是使用反射来减少耦合,更方便的调用和减少代码的使用量,使用反射直接调用class对象

public static Fruit buy(String Classname) throws Exception {

Fruit fruit = (Fruit) Class.forName(Classname).newInstance();

//使用反射获取到输入的当前class,然后使用里面的newInstance方法创建一个新的实例对象.将他强转成我们需要的类的类型

return fruit;

}

当有多种水果继承父类fruit时候

每次调用对象水果需要先引用对象

例如:Apple apple = new Apple();

但是使用工厂静态方法

public static Fruit getFruit(String name){//直接调用水果.然后判断再调用其中的内容

//工厂主要解决结藕问题

if (name.equals("苹果")){

return new Apple("苹果");

}else if(name.equals("柠檬")){

return new lemon("柠檬");

}

return null;

}

在结合反射

//需要水果的全限定类名

//反射主要解决种类过多else,if代码过多问题

public static Fruit getFruit2(String name) throws Exception {

return(Fruit)Class.forName(name).newInstance();

}

  

当有多种水果时候不用调用每种水果的对象后再引用

可以直接反射调用

Fruit fruit2 = FruitFactor.getFruit2("Com.YL.Bean.Apple");//通过第二种拿到苹果水果对象

System.out.println(fruit2);

Fruit fruit1 = FruitFactor.getFruit2("Com.YL.Bean.lemon");//通过第二种拿到柠檬水果对象

System.out.println(fruit1);

  

通过反射操作构造方法创建对象

这里告诉我们反射可以通过Constructor方法使用公用的构造方法,也可以通过getDeclaredConstructor方法获取私用的构造器方法,然后启动暴力反射允许访问,最后使用Constorcutor的newInstance创建实例对象.打印

  

Consturctor和Filed都继承与类 AccessibleObject所以能用setAccessible()方法

Class<Teacher> clazz = Teacher.class;//获取字节码对象,创造对象Teacher

//暴力反射

Constructor<Teacher> declaredConstructor = clazz.getDeclaredConstructor(String.class);

public [Constructor](../../java/lang/reflect/Constructor.html)<[T](../../java/lang/Class.html)> getConstructor

([Class](../../java/lang/Class.html)<?>... parameterTypes)

//这个方法要传入的参数是:参数类型的class对象

例如:String则传入String.class

declaredConstructor.setAccessible(true);

Teacher teacher04 = declaredConstructor.newInstance("尼玛");

System.out.println(teacher04);

  

通过反射调用成员变量

Class<Teacher> clazz = Teacher.class;//获取字节码对象

Teacher teacher = clazz.newInstance();

//创建实例对象teacher

//暴力反射获取

Field name1 = clazz.getDeclaredField("name");

name1.setAccessible(true);//让其合法被访问

name1.set(teacher,"老王"); System.out.println(name.get(teacher));

System.out.println(name1.get(teacher));

  

反射实际使用:写一个"框架",在不改变任何代码的前提下,创建任意类的对象,并且执行其中任意方法

步骤1.将需要创建的对象的全类名和需要执行的方法定义在配置文件中

步骤2.在程序中加载读取配置文件

2.1创建Properties对象

2.2获取Class目录下的配置文件

//获取 当前类 这个字节码文件对应的类加载器

类名.class.getClassLoader();

//返回这个资源对应的字节流

类加载器.getResourceAsStream(配置文件);

Properties对象.load()

2.3获取所需配置文件中定义的数据

String str = pro对象名.getProperty("数据名");

步骤3.使用反射技术来加载类文件进内存

步骤4/创建对象

步骤5.执行方法

  

反射的通用方法

创建一个方法,将需要的参数写好

//需求给指定对象的指定属性设置指定值

//指定对象不知道类型设定obj,指定属性名String,目标对象类型未知设定obj

public static void method(Object obj1,String filedName,Object obj2) throws Exception {

  

Class<?> clazz = obj1.getClass();//拿到指定对象的class

Field f = clazz.getDeclaredField(filedName);

f.setAccessible(true);

f.set(obj1,obj2);

//打印

System.out.println(obj1);

}

}

底层代码就是方法method的反射实现功能

执行:method(new Person(),"name","二狗");

  

反射越过泛型检查

原理:java中的反省检查生命周期只在源码阶段

故而通过反射运行时泛型检查已经没有

  

反射通用方法:给指定对象的指定属性设置指定值

public static void method(Object obj1,String filedName,Object obj2) throws Exception {

  

}
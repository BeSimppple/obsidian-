静态代理模式
	1.自定义代理类 实现和被代理类相同的接口
	2.自定义类中声明 被代理类对象
	3.在自定义类中的方法中使用被代理类对象调用方法
	**本质**:接口类的实现增强
	**实现**:
		直接在代理类中new一个被代理类对象
		例:Student stu = new Student();
		特点:能够控制被代理类对象的访问权限
		作用:提高代码的维护性,解耦,增强方法
		缺点:实现了接口,那么就必须实现所有接口中的方法
	//2个相同的类,1个被代理类:实现接口中所有方法 1个代理类实现接口中所有方法,同时可以选择性在需要的方法中加入特有方法增强方法
	2个方法都同时实现接口,(接口是两个都有的相同抽象方法)
**装饰着设计模式**
	1.定义装饰类实现和被装饰类相同的接口
	2.在被装饰类中声明被装饰类的引用
	3.在自定义类中的方法中使用被代理类对象调用方法
	在被装饰类中创建一个装饰类的成员变量
	例:private Student stu =null;
	生成有参构造方法
	外部调用时引入装饰类进行装饰
	**特点**:没有装饰类对象的控制权
	**优化方法**:
	做一个中间类去实现需要被增强的接口写入普通方法,再使用装饰类去继承这个中间类就有了所有方法,并且可以增强方法
**动态代理模式**
	**原理**:
		通过反射获取代理对象,因此不用像静态代理实现所有接口方法
	**使用需求**:
		1.被代理类必须要实现接口,因为动态代理基于接口
		2.被返回的代理类必须是接口
	通过Proxy类中的newProxyIInstance来实现增强
	.底层为反射获取代理对象,然后增强方法
	public static [Object](../../../java/lang/Object.html) newProxyInstance([ClassLoader](../../../java/lang/ClassLoader.html) loader, [Class](../../../java/lang/Class.html)<?>[] interfaces, [InvocationHandler](../../../java/lang/reflect/InvocationHandler.html) h)
	// ClassLoader loader: 被代理类的类加载器
	// Class<?>[] interfaces: 被代理类所实现的所有接口
	// InvocationHandler h : 执行增强的处理器
**实现步骤**:
	1创建被代理对象
	2.调用Proxy.newProxyInstance方法创建代理对象
	2.1
	传入被代理类的类加载器
	代理类.getClass().getClassLoader()
	传入被代理类所实现的所有接口
	代理类.getClass().geInterfaces();
	传入执行增强的处理器
	new InvocationHandler(){
	重写invoke方法
	[Object](../../../java/lang/Object.html) invoke([Object](../../../java/lang/Object.html) proxy,//被代理类 [Method](../../../java/lang/reflect/Method.html) method,//被代理类的原方法 [Object](../../../java/lang/Object.html)[] args)//被代理类的原方法的原参数的值
	可以通过获取被代理类方法名
	判断需要增强的方法名,加入增强方法,
	不需要增强的则返回原方法
	//完成
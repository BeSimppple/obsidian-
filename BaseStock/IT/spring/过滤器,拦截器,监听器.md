## 过滤器Filter

作用和原理:
	
Filter生命周期
	1.随着服务器的启动而初始化
	2.随着请求的发生而过滤
	3.随着服务器的关闭而销毁
执行流程:
	1.浏览器发起请求
	2.服务器会根据这个请求，创建request对象及response对象
	3.过滤器会持有request对象及response对象
	4.只有当过滤器放行之后，request对象及response对象才会传给Serlve
**过滤器链和拦截器的区别**
	![[过滤器,拦截器,监听器_image_1.jpg|350]]
	1、实现原理不同 过滤器和拦截器底层实现方式大不相同，过滤器 是基于函数回调的，拦截器 则是基于Java的反射机制（动态代理）实现的。
	2、使用范围不同 我们看到过滤器 实现的是 javax.servlet.Filter 接口，而这个接口是在Servlet规范中定义的，也就是说过滤器Filter 的使用要依赖于Tomcat等容器，导致它只能在web程序中使用。 而拦截器(Interceptor) 它是一个Spring组件，并由Spring容器管理，并不依赖Tomcat等容器，是可以单独使用的。不仅能应用在web程序中，也可以用于Application、Swing等程序中。
	3、触发时机不同 过滤器Filter是在请求进入容器后，但在进入servlet之前进行预处理，请求结束是在servlet处理完以后。拦截器 Interceptor 是在请求进入servlet后，在进入Controller之前进行预处理的，Controller 中渲染了对应的视图之后请求结束。
	4、拦截的请求范围不同 过滤器Filter执行了两次，拦截器Interceptor只执行了一次。这是因为过滤器几乎可以对所有进入容器的请求起作用，而拦截器只会对Controller中请求或访问static目录下的资源请求起作用。
	5、注入Bean情况不同 这是因为加载顺序导致的问题，拦截器加载的时间点在springcontext之前，而Bean又是由spring进行管理。
	6、控制执行顺序不同 过滤器用@Order注解控制执行顺序，通过@Order控制过滤器的级别，值越小级别越高越先执行。 拦截器默认的执行顺序，就是它的注册顺序，也可以通过Order手动设置控制，值越小越先执行

过滤器相关配置
初始化参数,
过滤路径:根据访问路径过滤
	1.完全匹配 : 以"/"开头
	2.目录匹配 : 以"/"开头，以"*"结尾
	3.后缀名匹配 : 以"*"开头，以后缀名结尾
也可以根据过滤的servlet名称进行过滤
过滤器的注解开发
WebInitParam[] initParams() default {};//初始化参数
等
可以使用过滤器的特性,进行编解码格式的设置

---
## 监听器(Listener)
概述:
1.事件源：事件发生的源头
2.监听器：事件发生后被触发的组件
3.事件：能够触发监听器的事
4.绑定：将事件源和监听器关联
servlet监听器(具体)
事件源：三大域对象
监听器：三类监听器
事件：域对象发生改变
绑定：在web.xml中配置监听器
监听器分类
一类监听器
-   监听域对象的创建、销毁
二类监听器
-   监听域对象中的属性的变更（属性添加、属性修改、属性移除）
三类监听器
-   监听域对象中的对象状态改变（对象绑定、对象解绑）
三类监听器很特殊,可以直接在对象中实现三类监听器(然后重写方法完善解绑和绑定状态时的方法)


---
## 拦截器interceptor









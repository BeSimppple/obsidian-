 一、Java基础篇
7.**ConcurrentHashMap原如何保证的线程安全？**
	ConcurrentHashMap的底层数据结构是：Segments数组(分段数组,每段可以自由充当一个数组自行扩容)+HashEntry数组(基于hashcode的数组)+链表
	它采用分段锁保证安全性。容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。
	内置ReentrantLock锁,是基于CAS自旋方式的乐观锁,低并发下效率高,特点是可重入性(避免死锁)
10.**如何保证ArrayList的线程安全？**
	1.主动写包装类,在add()方法和remove(),update()方法调用时加锁
	2.使用Collections帮助类的Collections.synchronizedList()方法
	3.直接使用Vector替代ArrayList,底层原理同ArrayList但是线程安全
13.**面向对象和面向过程的区别**
		主要区别:
	**1.抽象的对象不同:** 面向过程的编程思想是以过程为中心，将问题分解为一系列的步骤，然后按照一定的顺序依次执行这些步骤。而面向对象的编程思想则是以对象为中心，将问题分解为一些相互协作的对象，每个对象具有自己的属性和方法，通过消息传递的方式进行交互。
	**2.封装性不同:** 面向过程的编程思想强调的是数据和方法的分离，数据和方法是分开定义的。而面向对象的编程思想则强调的是将数据和方法封装在一起，通过接口来控制对数据的访问。
	**3.是否支持继承:** 面向对象的编程思想支持继承，一个类可以继承另一个类的属性和方法，并可以在此基础上进行扩展和修改。而面向过程的编程思想不支持继承，只能通过复制代码来实现类似的功能。
	**4.是否支持多态:** 面向对象的编程思想支持多态，同一个方法可以有不同的实现方式，具体的实现方式取决于调用该方法的对象。而面向过程的编程思想不支持多态，同一个方法只有一种实现方式。
 4.深拷贝和浅拷贝
	 浅拷贝仅引用地址,深拷贝全盘复制成新的内容
16.**什么是反射？**
	反射是一种机制
	通过获取类的class对象然后调用其属性或方法
	作用: 要操作权限不够的类属性和方法时、实现自定义注解时、动态加载第三方jar包时、按需加载类，节省编译和初始化时间；  
	获取class对象的方法有：class.forName(类路径)，类.class()，对象的getClass（）
17.**Java创建对象的几种方式?**
	(1)new关键字   (2)Class.newInstance  反射  (3)Constructor.newInstance
	(4)Clone方法   (5)反序列化
**二.Java多线程篇**
1. 什么是线程上下文切换
	是指当CPU从一个线程中转移到另一个线程时，需要保存当前线程的状态（包括程序计数器、寄存器、栈指针等）并恢复下一个线程的状态，这个过程就是线程上下文切换。
	总结:用线程池来避免频繁创建和销毁线程，或者使用协程等技术来减少线程的切换次数。 
3.**什么是死锁,?死锁的必要条件?**
	死锁是指双方都需要另一方资源但无法访问
	死锁必要条件:
	1. #独占锁:资源不可重复拥有
	2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
	3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；
	4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系；
5.Synchrpnized和lock的区别
	**Synchronized只能实现非公平锁，而Lock可以实现公平锁和非公平锁**
	Synchronized在发生异常时会由JVM自动释放锁，而Lock必须手动释放锁，否则容易出现死锁。
	Synchronized的性能相对较低，因为它会涉及到用户态和内核态的切换，而Lock的性能相对较高，因为它是基于CAS操作实现的。
6.什么是AQS锁(AbstractQueuedSynchronizer)?
	:AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架,是基于底层锁实现的，它是底层锁的一个上层的封装
	AQS的原理是，AQS内部有三个核心组件，一个是state代表加锁状态初始值为0，一个是获取到锁的线程，还有一个阻塞队列。当有线程想获取锁时，会以CAS的形式将state变为1，CAS成功后便将加锁线程设为自己。当其他线程来竞争锁时会判断state是不是0，不是0再判断加锁线程是不是自己，不是的话就把自己放入阻塞队列。这个阻塞队列是用双向链表实现的
	可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己，是的话state+1，释放锁的时候就将state-1。当state减到0的时候就去唤醒阻塞队列的第一个线程。
7.为什么AQS使用的双向链表？
	因为有一些线程可能发生中断 ，而发生中断时候就需要在同步阻塞队列中删除掉，这个时候用双向链表方便删除掉中间的节点
8.有哪些常见的AQS锁
	AQS分为独占锁和共享锁
	**ReentrantLock**（独占锁）：可重入，可中断，可以是公平锁也可以是非公平锁，非公平锁就是会通过两次CAS去抢占锁，公平锁会按队列顺序排队
	**Semaphore**（信号量）:设定一个信号量，当调用acquire()时判断是否还有信号，有就获取一个信号量，没有就阻塞等待其他线程释放信号量，当调用release()时释放一个信号量，唤醒阻塞线程。
	应用场景：允许多个线程访问某个临界资源时，如上下车，买卖票
	**CountDownLatch**（倒计数器）:给计数器设置一个初始值，当调用CountDown()时计数器减一，当调用await() 时判断计数器是否归0，不为0就阻塞，直到计数器为0。
	应用场景：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行
	**CyclicBarrier**（循环栅栏）:给计数器设置一个目标值,当调用await() 时会计数+1并判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值
	应用场景：多线程计算数据，最后合并计算结果的应用场景
10.**yield()和join()区别**
	yield方法是让其他线程有机会和他竞争(不释放锁)
	join方法是让本线程阻塞直到指定线程运行完毕(只会释放Thread的锁，不会释放线程对象的锁（可能会造成死锁）)
11.**线程池七大参数**
	1.  corePoolSize：核心线程数。
	2.  maximumPoolSize：最大线程数。
	3.  keepAliveTime：空闲线程存活时间。
	4.  TimeUnit：时间单位。
	5.  BlockingQueue：线程池任务队列。
	6.  ThreadFactory：创建线程的工厂。
	7.  RejectedExecutionHandler：拒绝策略。（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争
12.**介绍下JMM(Java内存模型 )**
	JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取
	具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的
	由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题
13.**保证并发安全的三大特性？**
	 原子性：一次或多次操作在执行期间不被其他线程影响
	可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道
	有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排
 14.volatile关键字
	 保证不同线程对它修饰的变量进行操作时的**可见性**，即一个线程修改了某个变量的值，新值对其他线程来说是立即可见的
14.**单例模式双重校验锁变量为什么使用 volatile 修饰？**
	禁止 JVM 指令重排序，对象的创建分为三个步骤：为实例对象分配内存，用构造器初始化成员变量，将实例对象引用指向分配的内存；实例对象在分配内存后时才不为null。如果分配内存后还未初始化就先将实例对象指向了内存，那么此时最外层的if会判断实例对象已经不等于null就直接将实例对象返回。而此时初始化还没有完成。
	|      |                            |                                                    |
	| ---- | -------------------------- | -------------------------------------------------- |
	| 时间 | 线程A                                   | 线程B                                              |
	| t1   | A1：分配对象的内存空间      |                                                    |
	| t2   | A3：设置single指向内存空间|                                                    |
	| t3   |                                                | B1:判断single是否为空                              |
	| t4   |                                                | B2:由于single不为null，线程B将访问single引用的对象 |
	| t5   | A2：初始化该对象                 |                                                    |
	| t6   | A4：访问single引用的对象    |                                                    |
	[详解](https://blog.csdn.net/u010002184/article/details/111876327)
15.**有哪些多线程的场景,什么情况下该考虑多线程?**
	1.当程序需要同时执行多个任务时,使用多线程并发执行
	2. 当程序需要等待某个操作完成时，可以使用多线程来避免阻塞主线程，从而提高程序的响应速度。
	3. 当程序需要定时执行某个任务时，可以使用多线程来实现定时任务的功能。
	4. 当程序需要处理大量数据时，可以使用多线程来对数据进行分片处理，从而提高程序的处理速度。
16.**什么是ThreadLocl,ThreadLocal原理**
	ThreadLocl是java中的一个类作用是提供给多线程一个局部变量
	原理是每个线程复制一份变量的副本,不同线程之间不可见，保证线程安全
17.什么是CAS锁
	比较和替换锁,会设置一个期望值,如果和期望值相符则修改
18.**Synchronized锁原理和优化**
	Synchronized锁的**基本原理是在对象头中的Mark Word中设置标志位来表示对象是否被锁定**，当一个线程尝试获取某个对象的Synchronized锁时，如果该对象未被锁定，该线程就会将对象头中的标志位设置为锁定状态，并将当前线程ID记录在对象头中，从而获得该对象的锁；如果该对象已经被锁定，那么该线程就会进入该对象的等待队列中等待锁的释放。
	**在JAVA6后引入了偏向锁,轻量锁,重量锁概念来优化Stnchronized锁**
19.如何根据 CPU 核心数设计线程池线程数量
	一般需要比cpu略多或相等可以充分利用cpu资源
	IO 密集型：线程中十分消耗Io的线程数*2  
	CPU密集型： cpu线程数量
**三.JVM篇**
1.**JVM运行时数据区（内存结构）**
	分为5个区域, 堆,虚拟机栈, 元空间 , 程序计数器 ,本地方法栈
2.**什么情况下会内存溢出？**
	栈溢出:递归不结算
	堆溢出: 强引用不释放  或  生成对象过多
3.JVM有哪些垃圾回收算法？
	常用:  **分代算法,   标记清除法,   复制算法(也叫标记复制)**
4.**GC如何判断对象可以被回收？**
	（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题
	（2）可达性分析法：GC Roots的根对象开始，递归地遍历所有从根对象开始可达的对象，将未访问到的对象标记为垃圾。
5.典型垃圾回收器
	1.Serial 最早的回收器(垃圾回收时所有线程必须暂停)
	2.CMS(标记-清除算法实现)
	3.G1 (标记 - 整理算法)
6.**类加载器和双亲委派机制**
	主要有三个类加载器    **根类加载器**,**扩展类加载器**,**应用类加载器**
	作用是
	将.class文件的字节码转换为内存中的java类
	**双亲委派模型** 
	原理是
	首先看是否已经加载过,然后找父类加载器能否执行,如果不能依次找子类加载器
	作用是
	保证类是安全的和避免重复加载,防止恶意代码通过自定义加载类加载恶意代码
7.JVM中有哪些引用类型？
	强引用：new的对象。哪怕内存溢出也不会回收
	-
	软引用：只有内存不足时才会回收
	-
	弱引用：每次垃圾回收都会回收
	-
	虚引用：必须配合引用队列使用，一般用于追踪垃圾回收动作
8.**类加载过程**
	加载,链接,初始化
		1. 加载就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。//class也就是运行时对象
		2. 连接(细分为验证,准备,分析)
		3. 验证 是否有正确的内部结构，并和其他类协调一致
		4. 准备 负责为类的静态成员分配内存，并设置默认初始化值
		5. 解析 将类的二进制数据中的符号引用替换为直接引用
		6. 初始化 就是对变量的初始化
9.**JVM类中代码初始化顺序**
	父类静态代码块和静态成员变量->子类静态代码块和静态成员变量->父类代码块和普通成员变量->父类构造方法->子类代码块和普成员变量->子类构造方法
10..**对象的创建过程**
	1：检查类是否已经被加载；
	2：为对象在堆上分配内存空间；
	3：为分配的内存空间初始化零值或null（为对象字段设置零值）；
	4：对对象进行其他设置（设置对象头）；
	5：执行构造方法。
11.对象头中有哪些信息
	记录锁的状态信息,
	元信息的地址,
	GC分代信息
	数组还会记录数组长度
**四.Mysql篇**
1.**MyIsAm和InnoDB的区别**
	1.innoDB是基于行锁的,MyIsAm是表锁
	2.innoDB支持事务和主.外键
	3.innoDB不保存表的具体行数,大量数据性能上会稍慢
2.mysql事务特性,事务的隔离级别
	原子性,一致性,隔离性,持久性
	**隔离级别分为**
	Serializable 序列化的  完全线程安全同步进行,效率低
	repeatable 可重复读, 会产生幻读
	read Committed读已提交 , 可能会导致不可重复读
	read Uncommitted 读未提交 可能会导致脏读,不可重复读
3.**事务靠什么保证**
	MySQL中的事务是通过ACID（原子性、一致性、隔离性和持久性）属性来保证数据的完整性和一致性的
	原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql
	一致性：由其他三大特性共同保证，是事务的目的
	隔离性：由MVCC(多版本并发控制)保证
	持久性：由redo log日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复
5.**什么是快照读和当前读**
	默认快照读不考虑当前数据同时被修改
	当前读是排他锁保证读取到最新数据,使用例如for update 实现
6.**MVCC是什么**
		在每个数据行上存储多个版本来实现的。每个事务在读取数据时，都会读取该数据行的当前版本。如果该数据行已被其他事务修改，则该事务将读取该数据行的先前版本。这样，每个事务都可以看到一个稳定的数据快照，而不会受到其他事务的影响。
	undolog日志：记录了数据历史版本
	readView:事务进行快照读时动态生成产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见
	隐藏字段DB_TRC_ID： 最近修改记录的事务ID 
	隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本
7.MySQL有哪些索引
	主键索引,次级索引,联合索引,全文索引(全局的倒排索引)
8.聚簇索引和非聚簇索引的区别
	非聚集索引的地址存储的是聚集索引,最终还是要靠聚集索引拿到具体数据
	聚集索引的数据是逻辑和物理排序相同,非聚集是逻辑排序但物理不一定
9.MySQL如何做慢SQL优化
	开启慢查询日志（ SET GLOBAL long_query_time=阈值;超过阈值的sql就会记录到慢查询日志当中），或查看执行计划（explain+SQL）。慢查询优化如下：
	（1）分析sql语句，是否加载了不需要的数据列
	（2）分析sql执行计划，字段有没有索引，索引是否失效，是否用对索引
	（3） 使用复杂查询时，尽量使用关联查询来代替子查询，并且最好使用内连接
	（4）orderby查找时使用索引进行排序，否则的话需要进行回表，然后在排序缓冲区中进行排序。
	（5）groupby查询时，同样要建立联合索引，避免使用到临时表
	（6）分页查询时，如果偏移量太大，比如要查询一百万条数据后的十条记录，可以使用主键+子查询的方式，避免进行全表扫描
	（7）使用count函数时直接使用count的话count(*)的效率最高，也可以额外创建一张表去统计不同表中的数据行数，但维护麻烦
	count(*)或count(唯一索引)或count(数字):表中总记录数，count(字段)不会统计null
	(8) 在写update语句时，where条件要添加使用索引，否则会锁会从行锁升级为表锁
	（9）表中数据是否太大，是不是要分库分表
10.为什么要用内连接而不用外连接？
	用外连接的话连接顺序是固定死的，比如left join，他必须先对左表进行全表扫描，然后一条条到右表去匹配；而内连接的话mysql会自己根据查询优化器去判断用哪个表做驱动。
	-
	子查询的话同样也会对驱动表进行全表扫描，所以尽量用小表做驱动表。
11.MySQL整个查询的过程
	1.  客户端先发送查询语句给服务器
	2.  服务器检查缓存，如果存在则返回
	3.  进行sql解析，生成解析树，再预处理，生成第二个解析树，最后再经过优化器，生成真正的执行计划
	4.  根据执行计划，调用存储引擎的API来执行查询
	5.  将结果返回给客户端。
12.执行计划中有哪些字段？
	id select_type ,type,keys,possible_keys,rows,extra,key_len
13.哪些情况索引会失效
	非空判断,前模糊查询,索引列参与计算或类型转换,违背最左匹配原则
14.B和B+数的区别，为什么使用B+数
	B树每个非叶子节点也存储的是直接数据,导致每一行的节点量存储更少,B+树只有叶子节点存储数据,其他非叶子节点存储的是叶子节点的索引地址,达到了每一行更多的索引减少了行数达到减少搜索时间
15.MySQL有哪些锁
	基于属性:共享锁,排他锁,
	基于粒度:行级锁,表级锁,间隙锁
16.Mysql内连接、左连接、右连接的区别
	内连接取量表交集部分，左连接取左表全部右表匹部分，右连接取右表全部坐表匹部分
17.sql执行顺序
	1.  from 
	2.  on 
	3.  join 
	4.  where 
	5.  group by(开始使用select中的别名，后面的语句中都可以使用)
	6.   avg,sum.... 
	7.  having 
	8.  select 
	9.  distinct 
	10.  order by
	11.  limit
18.如何设计数据库？
	（1）抽取实体，如用户信息，商品信息，评论
	-
	（2）分析其中属性，如用户信息：姓名、性别...
	-
	（3）分析表与表之间的关联关系
	-
	然后可以参考第三范式进行设计，设计主键时，主键要尽量小并且定义为自增和不可修改。
19.where和having的区别？
	where是约束声明，having是过滤声明，where早于having执行，并且where不可以使用聚合函数，having可以
20.三大范式
	第一范式:每个列不可拆分
	第二范式第一范式基础上非主键列完全依赖于主键，而不能是依赖于主键的一部分。
	第三范式在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键(消除传递依赖)。
21.char和varchar的区别
	char是不可变的，最大长度为255，varchar是可变的字符串，最大长度为2^16
22.InnoDB 什么情况下会产生死锁
	1、互斥条件：一个资源每次只能被一个进程使用；
	2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
	3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；
	4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系；
23.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？
	innodb 引擎：
	MySQL8.0前，下次自增会取表中最大 id + 1。原理是最大id会记录在内存中，重启之后会重新读取表中最大的id
	MySQL8.0后，仍从删除数据 id 后算起。原理是它将最大id记录在redolog里了
	-
	myisam：
	自增的 id 都从删除数据 id 后算起。原理是它将最大id记录到数据文件里了
**五.常用开发框架系列**
1.什么是Spring？
	Spring是一种框架思想
2.IOC是什么？
	翻转控制的编程模式,将new来创建实例的方式变为从容器中通过反射获取实例
3.AOP是什么？ 
	Aspect-Oriented Programming
	将非主要程序或重复程序进行封装,然后通过动态代理方式根据运行的节点在不修改代码的情况下增强代码,提高可用性和扩展性
4.如何定义一个全局异常处理类？
	想要定义一个全局异常处理类的话，我们需要在这个类上添加@ContaollerAdvice注解，然后定义一些用于捕捉不同异常类型的方法，在这些方法上添加@ExceptionHandler(value = 异常类型.class)和@ResponseBody注解，方法参数是HttpServletRequest和异常类型，然后将异常消息进行处理。
	-
	如果我们需要自定义异常的话，就写一个自定义异常类，该类需要继承一个异常接口，类属性包括final类型的连续id、错误码、错误信息，再根据需求写构造方法； 
5.如何使用aop自定义日志？(实际应用)
	第一步：创建一个切面类，把它添加到ioc容器中并添加@Aspect注解
	-
	第二步： 在切面类中写一个通知方法，在方法上添加通知注解并通过切入点表达式来表示要对哪些方法进行日志打印，然后方法参数为JoinPoint
	-
	第三步：通过JoinPoint这个参数可以获取当前执行的方法名、方法参数等信息，这样就可以根据需求在方法进入或结束时打印日志
6.循环依赖是什么，怎么解决的？
	当bean A依赖于bean B,且bean B也依赖于bean A时
	必要条件:1.  出现循环依赖的Bean必须要是单例 2.不能全是构造器注入(构造器代码的依赖)
	主要原因:代码设计有问题
	解决方案:  
	spring自带的三级缓存(概念属于中间层)
	1. 重构代码：通过重新设计代码结构，消除循环依赖  (耗时)
	2. 引入中间层：通过引入一个中间层，将循环依赖转化为单向依赖    (增加代码复杂度)
	3. 使用依赖注入：通过使用依赖注入框架，将循环依赖交给框架处理  (框架学习成本)
	4. 使用懒加载初始化：通过延迟初始化的方式，将循环依赖推迟到真正需要使用的时候再解决  (需要注意初始化时机)
		1. @PostConstruct注解
		2. 使用Setter/Field注入
		3. 使用@Lazy
		4.  实现 ApplicationContextAware and InitializingBean
7.Bean 的作用域
	singleton
	prototype
	session
	request
	application
	websocket
8.Bean 生命周期
	实例化  ---无参构造
	属性话  ---set方法
	初始化   ---init方法
	销毁  ---destory方法
10.spring事务生效方法,失效场景
	可以使用编程式和声明式开启事务
	本质是通过aop实现的事务控制
	失效场景:
	1. 不是一个容器
	2. 事务方法不是public
	3. 方法使用 final 或 static关键字
	4. 同一类中，一个没有添加事务的方法调用另外以一个添加事务的方法，事务不生效
	5. 业务自己捕获了异常，事务会认为程序正常秩序
	6. spring事务默认只回滚运行时异常，可以用rollbackfor属性设置
11.spring事务的隔离级别
	default:默认级别，使用数据库自定义的隔离级别
	其它四种隔离级别与mysql一样
12.spring事务的传播行为
	常用两个:
	REQUIRED 如果当前没有事务就创建一个事务 如果已经存在一个事务中,一般的选择(默认值)
	SUPPORTS:支持当前事务,如果当前没有事务,就以非事务方式执行(没有事务)
	其他:
	never
	nested
	mandotary
	requires_new
	not_supported
12.spring用了哪些设计模式
	BeanFactory用了工厂模式，AOP用了动态代理模式，RestTemplate用来模板方法模式，SpringMVC中handlerAdaper用来适配器模式，Spring里的监听器用了观察者模式,IOC使用了单例模式
14.SpringMVC工作原理
	1, 用户发送请求至前端控制器DispatcherServlet
	2, DispatcherServlet收到请求调用HandlerMapping处理器映射器。
	3, 返回处理器执行链HandlerExecutionChain。
	4, DispatcherServlet通过HandlerAdapter处理器适配器调用合适的处理器
	5, 执行处理器handler
	6, handler执行完成返回ModelAndView(数据及视图)
	7, HandlerAdapter将果ModelAndView返回给DispatcherServlet
	8, DispatcherServlet将ModelAndView传给ViewReslover视图解析器
	9, ViewReslover解析后返回具体View对象
	10, DispatcherServlet对View进行渲染视图（即将模型数据填充至视图中）。
	11, DispatcherServlet响应用户
15.springboot自动配置原理
	启动类@SpringbootApplication注解下，有三个关键注解
	-
	（1）@springbootConfiguration:表示启动类是一个自动配置类
	-
	（2）@CompontScan:扫描启动类所在包外的组件到容器中
	-
	（3）@EnableConfigutarion:最关键的一个注解，他拥有两个子注解，其中@AutoConfigurationpackageu会将启动类所在包下的所有组件到容器中，@Import会导入一个自动配置文件选择器，他会去加载META_INF目录下的spring.factories文件，这个文件中存放很大自动配置类的全类名，这些类会根据元注解的装配条件生效，生效的类就会被实例化，加载到ioc容器中
16.springboot常用注解
	@SpringBootApplication
	@AutoWired
	@PathVariable
	@Bean
	@AutoConfigurationPacage
	@RestController
	@ResponseBody
	@RequestBody
	@Transaction
17.spring的bean是线程安全的吗？
	spring的默认bean作用域是单例的，单例的bean不是线程安全的，但是开发中大部分的bean都是无状态的，不具备存储功能，比如controller、service、dao，他们不需要保证线程安全。
	-
	如果要保证线程安全，可以将bean的作用域改为prototype，比如像Model View。
	-
	另外还可以采用ThreadLocal来解决线程安全问题。ThreadLocal为每个线程保存一个副本变量，每个线程只操作自己的副本变量。
18.spring主要解决什么问题?
	解决服务之间的通信、容灾、负载平衡、冗余问题，能方便服务集中管理，常用组件有注册中心、配置中心、远程调用。服务熔断、网关
六.Redis系列
1.redis为什么快？
	1.完全基于内存的IO
	2.绝大部分情况是单线程(避免竞争和锁定)
		Redis的网络IO和键值对的读写都是由一个线程来完成的，Redis的请求时包括获取（Socket读），解析，执行，内容返回（socket写）等都是由一个顺序串行的主线程处理，这就是所谓的单线程。
		在Redis6.0中新增加了多线程的功能来提高I/O读写性能，他的主要实现思路是将**主线程的IO读写任务拆分给一组独立的线程去执行**，将最耗时的socket读取，请求解析，写入单独外包出去，剩下的命令执行任然是由主线程串行执行和内存的数据交互。
		异步删除或大数据量操作等IO多路复用操作是多线程
	3.高效,简单的数据结构(Hash等O(1)结构)
	4.采用IO多路复用和非阻塞IO
		多路:多个客户端访问
		复用:单进程处理多任务套接字
		原理从**select->poll→epol**阶段
		select是不断遍历访问任务是否完成,最多同时管理1024个
		polll使用pollfd数组来代替select中的bitmap，数组中没有1024的限制,是管理量更大的select
		epoll改进poll,只轮询那些真正发出了事件的流，并且只依次顺序的处理就绪的流,遍历的时候如果未完成则告诉任务完成后执行XX规范操作(减少遍历次数)
2.redis持久化机制
	使用rdb或aof方式实现持久化
	使用bgsave异步同步或save手动同步或系统根据条件触发
3.Redis如何实现key的过期删除？
	默认定期删除+惰性删除  可以根据需求配置删除策略
	定期删除:抽选一定数量的key检查是否过期然后删除
	惰性删除:访问时判断key是否过期,再行删除
4.Redis数据类型
	常用List  String Hash Set  ZSet(SortSet) Pub/Sub
	场景:String缓存json信息
	List可以做消息队列
	Set做去重好友列表
	Zset做排行榜
5.Redis缓存穿透,缓存击穿,缓存雪崩如何解决？
	**缓存穿透**是由于访问不存在的空值造成的永远访问数据库而缓存失效,可以设置对应空值缓存来解决,并设置例如明显无效的条件先做筛选(例如:id<0)->布隆过滤器
	**缓存击穿**是热点数据过期突然大量访问数据库,发现热点数据失效时加互斥锁让只有一个线程访问给足够时间加载到缓存,或者热点数据永不过期
	**缓存雪崩**是由于redis缓存集体过期导致的,可以设置函数来分散峰值时间解决
8.Redis分布式锁的实现原理
	设置setnx+setex让其他服务去访问缓存状态如果为0则代表可以获取锁并将状态改为1
	超时等导致的死锁和可重入性通过Redision解决
9.Redis集群方案
	哨兵模式 1主多从  主负责读写  从只负责读 (主节点宕机通过投票选举新的主节点)
	集群模式  多集群皆可读写
10.Redis集群主从同步原理
	主从同步第一次是全量同步：slave第一次请求master节点会根据replid判断是否是第一次同步，是的话master会生成RDB发送给slave。
	=
	后续为增量同步：在发送RDB期间，会产生一个缓存区间记录发送RDB期间产生的新的命令,slave节点在加载完后，会持续读取缓存区间中的数据
11.Redis缓存一致性解决方案
	用中间件canal订阅binlog日志提取需要删除的key，然后另写一段非业务代码去获取key并尝试删除，若删除失败就把删除失败的key发送到消息队列，然后进行删除重试
12.Redis内存淘汰策略
	常用:(1)淘汰最久没使用的（2）淘汰一段时间内最少使用的（3）淘汰快要过期的
**七.计算机网络系列**
1.TCP / IP模型​编辑
	![[每日八股文(2)_image_1.png]]

 2.浏览器输入地址后做了什么？
	![[tmp1683523204614_每日八股文(2)_image_1.png]]
 
 3.TCP三次握手
	![[每日八股文(2)_image_2.png]]

4.为什么TCP不能两次握手
	假设是两次握手，若客户端发起的连接请求阻塞在网络中，会造成该报文的重传，这时服务收到连接请求后会立刻进入连接状态，当双方传输完数据结束连接后，第一次阻塞的请求突然又到达了服务端，此时服务端又进入连接状态，而客户端不会响应服务端的连接确认报文
5.TCP四次挥手
	![[每日八股文(2)_image_3.png]]

6.为什么要进入时间等待状态？
	若客户端发送确认释放包后直接关闭，而服务端因为某种原因没有收到客户端的确认释放包，就会一直发送确认请求，而客户端永远不会再响应该请求。
7.TCP 滑动窗口
	本质是批量传输数据,窗口大小由接收方决定,
8.TCP拥塞控制
	有门限变量,一开始传入小数据,然后慢启动算法指数增长到门限后切换成拥堵避免算法,发生拥堵时立即将cwnd/2然后门限=cwnd 进入快速恢复算法重发丢失信息后,3次接收到ack信息确认不拥堵后重启避免算法
9.TCP超时重传
	基于时间的超时重传RTO和RTT参数,RTO略大于RTT
	基于数据的tcp快速重传机制,在三次接收到相同ack信息后通过SACK的缓存地图确认丢包内容进行重传,通过D-SACK确认是否网络延迟造成,而后续的已经收到的将放在缓存区中下一次直接从最新的包开始
10.TCP可靠传输的实现
	滑动窗口协议
	堵塞处理算法
	动态流量控制
	重传机制
	校验和
	序列号和确认应答机制
11.TCP报头有哪些信息
	![[每日八股文(2)_image_4.png]]

12.状态码
	1xx:请求正在处理
	2xx:请求成功处理
	3xx:请求重定向   301：永久重定向      302：临时重定向       304：使用本地缓存
	4xx:客户端错误   400：请求格式错误   403：没有访问权限    415：请求体过大
	5xx:服务端错误
13.http与https的区别
	**HTTPS 使用TLS (SSL) 来加密普通的HTTP 请求和响应，并对这些请求和响应进行数字签名**
14.socket通信流程
	1.服务端创建socket并调用bind()绑定端口
	2.服务端调用listen监听
	3.客户端创建socket并调用connect()请求链接服务端
	4.服务端被动调用accept()与客户端创建链接
	5.客户端调用send()发送信息
	6.服务店receive()接收到信息
	7.客户端请求结束链接,服务端收到结束链接
**八.linux系列**
1.linux常用命令
	ls 查看当前文件夹下全部文件
	vi 编辑文件
	cd 切换地址
	rm 删除
	man xxx（命令） 可以查看有哪些参数
	tab键智能补全
	cd命令：用于切换当前目录
	ls命令：查看文件与目录的命令，list之意
	mkdir命令：创建
	rm命令：删除
	mv命令：该命令用于移动文件、目录或更名，move之意
	cp命令：该命令用于复制文件，copy之意
	find命令：find是一个基于查找的功能
	ps命令：用于将某个时间点的进程运行情况选取下来并输出，process之意
	kill命令：用于向某个工作（%jobnumber）或者是某个PID（数字）传送一个信号，它通常与ps和jobs命令一起使用 杀死进程
	tar命令：该命令用于对文件进行打包，默认情况并不会压缩
	chmod命令：该命令用于改变文件的权限
	nohup命令：不挂断地运行命令。
	sudo命令: super do使普通用户也能快速调用管理员权限的命令(使用需要输入管理员账号密码)
2.linux的io模型
	iO是对磁盘或网络数据的读写，用户进程读取一次IO请求分为两个阶段：等待数据到达内核缓冲区和将内核缓冲区数据拷贝到用户空间，当用户去内核中拷贝数据时，要从用户态转为核心态
	**5种io模型:**
	(1)同步阻塞IO模型
	用户进程发起io调用后会被阻塞，等待内核缓冲区数据准备完毕时就被唤醒，将内核数据复制到用户进程。这两个阶段都是阻塞的
	(2)同步非阻塞IO模型
	用户进程发起IO调用后，若内核缓冲区数据还未准备好，进程会继续干别的事，每隔一段时间就去看看内核数据是否准备好。不过将内核数据复制到用户进程这个阶段依旧是阻塞的
	(3)IO多路复用模型
	linux中把一切都看成文件，每个文件都有一个文件描述符（FD）来关联， IO多路复用模型就是复用单个进程同时监测多个文件描述符，当某个文件描述符可读或可写，就去通知用户进程。
	(4)信号IO模型
	用户进程发起IO调用后，会向内核注册一个信号处理函数然后继续干别的事，当内核数据准备就绪时就通知用户进程来进行拷贝。
	（5）异步非阻塞模型
	前面四种全是同步的。进程在发起IO调用后，会直接返回结果。待内核数据准备好时，由内核将数据复制给用户进程。两个阶段都是非阻塞的
3.epoll的LT和ET模式
	LT（默认）：水平触发，当FD有数据可读的时候，那么每次 epoll_wait都会去通知用户来操作直到读完
	-
	ET：边缘触发，当FD有数据可读的时候，它只会通知用户一次，直到下次再有数据流入才会再通知，所以在ET模式下一定要把缓冲区的数据一次读完
**九.其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等...）**
1.Java如何实现统计在线人数的功能？
	设置一个count缓存值在redis
2.RabbitMQ如何保证消息不丢失？ 
	重试机制和报错机制,进行函数补偿和死信队列手动处理
4.设计模式六大原则
	（1）单一职责原则：一个类或者一个方法只负责一项职责，尽量做到类只有一个行为引起变化；
	（2）里氏替换原则：子类可以扩展父类的功能，但不能改变原有父类的功能
	（3）依赖倒置原则：高层模块不应该依赖底层模块，两者都应该依赖接口或抽象类
	（4）接口隔离原则：建立单一接口，尽量细化接口
	（5）迪米特原则：只关心其它对象能提供哪些方法，不关心过多内部细节
	（6）开闭原则：对于拓展是开放，对于修改是封闭的
5.排序算法的时间复杂度
	![[每日八股文(2)_image_5.png]]

6.大量数据排名，采用什么数据结构
	SortSet,排序算法当数据量大且无序程度高采用堆排序,无序程度低采用快速排序
7.二叉树和堆之间联系或区别
	二叉树是子节点有序的左大右小结构,对节点遍历后会得到有序集合而堆是父节点必然大于或小于子节点但子节点是无序的,遍历后不能保证有序
8.hash表冲突的解决方法
	开放地址法：有线性探测法和平方探测法，当发生冲突时，继续往后找  
	**再哈希法：构造多个哈希函数，发生冲突后使用下一个函数**
	**链地址法：将hash值相同的记录用链表链接起来**
	建立公共溢出区：将哈希表分为基础表和益处表两部分，发生冲突的填入益处表
9.cookie和session的区别
	cookie是存在本地的令牌,session是存在会话的缓存
10.RabbitMQ如何保证消费顺序
	可以设置4条queue为1条达到有序消费
10.Nginx反向代理是什么，负载均衡算法有哪些？
	由nginx决定哪个服务器执行任务叫反向代理,外界接触的只有nginx
	负载均衡有轮询（默认）、带权轮询、ip_hash（按ip哈希结果分配，能解决session共享问题）、url_hash(按访问的URL的哈希结果分配)、fair（根据服务端响应时间分配，响应时间短优先）
11..如何用springSecurity做的认证授权？

**实习中供应链项目的收获**
1.熟悉了代码开发规范
	（1）外部接口不可放到事务代码里，
	* 比如入库信息要推送到财务云系统当中，但是推送的成功或失败不影响主体业务的进行，这种情况调用财务云系统的接口时要进行异步处理，避免请求出错导致事务时间过长影响主体业务流程
	* 移库和出库时要对某局的数据库也进行操作，某局数据库的成功或失败影响主体业务的进行，这种情况需要先进行数据库操作，再根据第三方接口返回成功还是失败进行提交事务或回滚事务
	(2)不可在循环里操作数据库
2.前后端联调经常遇到的问题：
	1.请求方式不匹配
	2.json、x-wwww-form-urlencoded混乱的错误
	3.前后端参数不一致，空指针异常，数据类型不匹配
	4.mp生成的分布式id是19位，JavsScrip只会处理16位，将id生成策略改为String类型
	5.跨域问题：跨域问题是在访问协议、ip地址、端口号这三个有任何一个不一样，相互访问就会出现跨域，可以通过Spring注解解决跨域的 @CrossOrigin，也可以使用nginx反向代理、网关
	6.maven加载项目时，默认不会加载src-java文件夹的xml类型文件，可以 将xml放到resources文件夹下，也可以在yaml和pom中添加配置 



**秒杀项目相关问题：**
1.项目流程

2.提升qps的操作










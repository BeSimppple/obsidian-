 一、Java基础篇
7.ConcurrentHashMap原如何保证的线程安全？
	ConcurrentHashMap的底层数据结构是：Segments数组(分段数组,每段可以自由充当一个数组自行扩容)+HashEntry数组(基于hashcode的数组)+链表
	它采用分段锁保证安全性。容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。
	内置ReentrantLock锁,是基于CAS自旋方式的乐观锁,低并发下效率高,特点是可重入性(避免死锁)
10.如何保证ArrayList的线程安全？
	1.主动写包装类,在add()方法和remove(),update()方法调用时加锁
	2.使用Collections帮助类的Collections.synchronizedList()方法
	3.直接使用Vector替代ArrayList,底层原理同ArrayList但是线程安全
13.面向对象和面向过程的区别
		主要区别:
	**1.抽象的对象不同:** 面向过程的编程思想是以过程为中心，将问题分解为一系列的步骤，然后按照一定的顺序依次执行这些步骤。而面向对象的编程思想则是以对象为中心，将问题分解为一些相互协作的对象，每个对象具有自己的属性和方法，通过消息传递的方式进行交互。
	**2.封装性不同:** 面向过程的编程思想强调的是数据和方法的分离，数据和方法是分开定义的。而面向对象的编程思想则强调的是将数据和方法封装在一起，通过接口来控制对数据的访问。
	**3.是否支持继承:** 面向对象的编程思想支持继承，一个类可以继承另一个类的属性和方法，并可以在此基础上进行扩展和修改。而面向过程的编程思想不支持继承，只能通过复制代码来实现类似的功能。
	**4.是否支持多态:** 面向对象的编程思想支持多态，同一个方法可以有不同的实现方式，具体的实现方式取决于调用该方法的对象。而面向过程的编程思想不支持多态，同一个方法只有一种实现方式。
 4.深拷贝和浅拷贝
16.什么是反射？
	反射是一种机制
	通过获取类的class对象然后调用其属性或方法
	要操作权限不够的类属性和方法时、实现自定义注解时、动态加载第三方jar包时、按需加载类，节省编译和初始化时间；  
	获取class对象的方法有：class.forName(类路径)，类.class()，对象的getClass（）
17.Java创建对象的几种方式?
	(1)new关键字   (2)Class.newInstance  反射  (3)Constructor.newInstance
	(4)Clone方法   (5)反序列化
**二.Java多线程篇**
1. 什么是线程上下文切换
	是指当CPU从一个线程中转移到另一个线程时，需要保存当前线程的状态（包括程序计数器、寄存器、栈指针等）并恢复下一个线程的状态，这个过程就是线程上下文切换。
	总结:用线程池来避免频繁创建和销毁线程，或者使用协程等技术来减少线程的切换次数。 
3.什么是死锁,?死锁的必要条件?
	死锁是指双方都需要另一方资源但无法访问
	死锁必要条件:
	1. #独占锁:资源不可重复拥有
	2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
	3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；
	4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系；
5.Synchrpnized和lock的区别
	Synchronized只能实现非公平锁，而Lock可以实现公平锁和非公平锁
	Synchronized在发生异常时会由JVM自动释放锁，而Lock必须手动释放锁，否则容易出现死锁。
	Synchronized的性能相对较低，因为它会涉及到用户态和内核态的切换，而Lock的性能相对较高，因为它是基于CAS操作实现的。
6.什么是AQS锁?
	:AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架,是基于底层锁实现的，它是底层锁的一个上层的封装
	AQS的原理是，AQS内部有三个核心组件，一个是state代表加锁状态初始值为0，一个是获取到锁的线程，还有一个阻塞队列。当有线程想获取锁时，会以CAS的形式将state变为1，CAS成功后便将加锁线程设为自己。当其他线程来竞争锁时会判断state是不是0，不是0再判断加锁线程是不是自己，不是的话就把自己放入阻塞队列。这个阻塞队列是用双向链表实现的
	可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己，是的话state+1，释放锁的时候就将state-1。当state减到0的时候就去唤醒阻塞队列的第一个线程。
7.为什么AQS使用的双向链表？
	因为有一些线程可能发生中断 ，而发生中断时候就需要在同步阻塞队列中删除掉，这个时候用双向链表方便删除掉中间的节点
8.有哪些常见的AQS锁
	AQS分为独占锁和共享锁
	ReentrantLock（独占锁）：可重入，可中断，可以是公平锁也可以是非公平锁，非公平锁就是会通过两次CAS去抢占锁，公平锁会按队列顺序排队
	Semaphore（信号量）:设定一个信号量，当调用acquire()时判断是否还有信号，有就获取一个信号量，没有就阻塞等待其他线程释放信号量，当调用release()时释放一个信号量，唤醒阻塞线程。
	应用场景：允许多个线程访问某个临界资源时，如上下车，买卖票
	CountDownLatch（倒计数器）:给计数器设置一个初始值，当调用CountDown()时计数器减一，当调用await() 时判断计数器是否归0，不为0就阻塞，直到计数器为0。
	应用场景：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行
	CyclicBarrier（循环栅栏）:给计数器设置一个目标值,当调用await() 时会计数+1并判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值
	应用场景：多线程计算数据，最后合并计算结果的应用场景
10.yield()和join()区别
	yield方法是让其他线程有机会和他竞争
	join方法是让本线程阻塞直到指定线程运行完毕
11.线程池七大参数
	1.  corePoolSize：核心线程数。
	2.  maximumPoolSize：最大线程数。
	3.  keepAliveTime：空闲线程存活时间。
	4.  TimeUnit：时间单位。
	5.  BlockingQueue：线程池任务队列。
	6.  ThreadFactory：创建线程的工厂。
	7.  RejectedExecutionHandler：拒绝策略。（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争
12.介绍下JMM(Java内存模型 )
	JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取
	具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的
	由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题
13.保证并发安全的三大特性？
	 原子性：一次或多次操作在执行期间不被其他线程影响
	可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道
	有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排
 14.volatile
14.单例模式双重校验锁变量为什么使用 volatile 修饰？
	禁止 JVM 指令重排序，new Object()分为三个步骤：为实例对象分配内存，用构造器初始化成员变量，将实例对象引用指向分配的内存；实例对象在分配内存后实才不为null。如果分配内存后还未初始化就先将实例对象指向了内存，那么此时最外层的if会判断实例对象已经不等于null就直接将实例对象返回。而此时初始化还没有完成。
	[详解](https://blog.csdn.net/u010002184/article/details/111876327)
15.有哪些多线程的场景,什么情况下该考虑多线程?
	1.当程序需要同时执行多个任务时,使用多线程并发执行
	2. 当程序需要等待某个操作完成时，可以使用多线程来避免阻塞主线程，从而提高程序的响应速度。
	3. 当程序需要定时执行某个任务时，可以使用多线程来实现定时任务的功能。
	4. 当程序需要处理大量数据时，可以使用多线程来对数据进行分片处理，从而提高程序的处理速度。
16.什么是ThreadLocl,ThreadLocal原理
	ThreadLocl是java中的一个类作用是提供给多线程一个局部变量
	原理是每个线程复制一份变量的副本,不同线程之间不可见，保证线程安全
17.什么是CAS锁
	比较和替换锁,会设置一个期望值,如果和期望值相符则修改
18.Synchronized锁原理和优化
	Synchronized锁的基本原理是在对象头中的Mark Word中设置标志位来表示对象是否被锁定，当一个线程尝试获取某个对象的Synchronized锁时，如果该对象未被锁定，该线程就会将对象头中的标志位设置为锁定状态，并将当前线程ID记录在对象头中，从而获得该对象的锁；如果该对象已经被锁定，那么该线程就会进入该对象的等待队列中等待锁的释放。
	在JAVA6后引入了偏向锁,轻量锁,重量锁概念来优化Stnchronized锁
19.如何根据 CPU 核心数设计线程池线程数量
	一般需要比cpu略多或相等可以充分利用cpu资源
	IO 密集型：线程中十分消耗Io的线程数*2  
	CPU密集型： cpu线程数量
**三.JVM篇**
1.JVM运行时数据区（内存结构）
	分为5个区域, 堆,虚拟机栈, 元空间 , 程序计数器 ,本地方法栈
2.什么情况下会内存溢出？
	栈溢出:递归不结算
	堆溢出: 强引用不释放  或  生成对象过多
3.JVM有哪些垃圾回收算法？
	常用:  **分代算法,   标记清除法,   复制算法(也叫标记复制)**
4.GC如何判断对象可以被回收？
	（1）引用计数法：已淘汰，为每个对象添加引用计数器，引用为0时判定可以回收，会有两个对象相互引用无法回收的问题
	（2）可达性分析法：GC Roots的根对象开始，递归地遍历所有从根对象开始可达的对象，将未访问到的对象标记为垃圾。
5.典型垃圾回收器
	1.Serial 最早的回收器(垃圾回收时所有线程必须暂停)
	2.CMS(标记-清除算法实现)
	3.G1 (标记 - 整理算法)
6.类加载器和双亲委派机制
	主要有三个类加载器根类加载器,扩展类加载器,应用类加载器
	作用是将.class文件的字节码转换为内存中的java类
	**双亲委派模型** 
	原理是首先看是否已经加载过,然后找父类加载器能否执行,如果不能依次找子类加载器
	作用是保证类是安全的和避免重复加载,防止恶意代码通过自定义加载类加载恶意代码
7.JVM中有哪些引用类型？
	强引用：new的对象。哪怕内存溢出也不会回收
	-
	软引用：只有内存不足时才会回收
	-
	弱引用：每次垃圾回收都会回收
	-
	虚引用：必须配合引用队列使用，一般用于追踪垃圾回收动作
8.类加载过程
	加载,链接,初始化
		1. 加载就是指将class文件读入内存，并为之创建一个Class对象。任何类被使用时系统都会建立一个Class对象。//class也就是运行时对象
		2. 连接(细分为验证,准备,分析)
		3. 验证 是否有正确的内部结构，并和其他类协调一致
		4. 准备 负责为类的静态成员分配内存，并设置默认初始化值
		5. 解析 将类的二进制数据中的符号引用替换为直接引用
		6. 初始化 就是对变量的初始化
9.JVM类中代码初始化顺序
	父类静态代码块和静态成员变量->子类静态代码块和静态成员变量->父类代码块和普通成员变量->父类构造方法->子类代码块和普成员变量->子类构造方法
10..对象的创建过程
	1：检查类是否已经被加载；
	2：为对象在堆上分配内存空间；
	3：为分配的内存空间初始化零值或null（为对象字段设置零值）；
	4：对对象进行其他设置（设置对象头）；
	5：执行构造方法。
11.对象头中有哪些信息
	记录锁的状态信息,
	元信息的地址,
	GC分代信息
	数组还会记录数组长度
**四.Mysql篇**
1.MyIsAm和InnoDB的区别
	1.innoDB是基于行锁的,MyIsAm是表锁
	2.innoDB支持事务和主.外键
	3.innoDB不保存表的具体行数,大量数据性能上会稍慢
2.mysql事务特性,事务的隔离级别
	隔离级别分为
	Serializable 序列化的  完全线程安全同步进行,效率低
	repeatable 可重复读, 会产生幻读
	read Committed读已提交 , 可能会导致不可重复读
	read Uncommitted 读未提交 可能会导致脏读,不可重复读
3.事务靠什么保证
	MySQL中的事务是通过ACID（原子性、一致性、隔离性和持久性）属性来保证数据的完整性和一致性的
	原子性：由undolog日志保证，他记录了需要回滚的日志信息，回滚时撤销已执行的sql
	一致性：由其他三大特性共同保证，是事务的目的
	隔离性：由MVCC(多版本并发控制)保证
	持久性：由redo log日志和内存保证，mysql修改数据时内存和redolog会记录操作，宕机时可恢复
5.什么是快照读和当前读
	默认快照读不考虑当前数据同时被修改
	当前读是排他锁保证读取到最新数据,使用例如for update 实现
6.MVCC是什么
		在每个数据行上存储多个版本来实现的。每个事务在读取数据时，都会读取该数据行的当前版本。如果该数据行已被其他事务修改，则该事务将读取该数据行的先前版本。这样，每个事务都可以看到一个稳定的数据快照，而不会受到其他事务的影响。
	undolog日志：记录了数据历史版本
	readView:事务进行快照读时动态生成产生的视图，记录了当前系统中活跃的事务id，控制哪个历史版本对当前事务可见
	隐藏字段DB_TRC_ID： 最近修改记录的事务ID 
	隐藏字段DB_Roll_PTR： 回滚指针，配合undolog指向数据的上一个版本
7.MySQL有哪些索引
	主键索引,次级索引,联合索引,全文索引(全局的倒排索引)
8.聚簇索引和非聚簇索引的区别
	非聚集索引的地址存储的是聚集索引,最终还是要靠聚集索引拿到具体数据
	聚集索引的数据是逻辑和物理排序相同,非聚集是逻辑排序但物理不一定
9.MySQL如何做慢SQL优化
	开启慢查询日志（ SET GLOBAL long_query_time=阈值;超过阈值的sql就会记录到慢查询日志当中），或查看执行计划（explain+SQL）。慢查询优化如下：
	（1）分析sql语句，是否加载了不需要的数据列
	（2）分析sql执行计划，字段有没有索引，索引是否失效，是否用对索引
	（3） 使用复杂查询时，尽量使用关联查询来代替子查询，并且最好使用内连接
	（4）orderby查找时使用索引进行排序，否则的话需要进行回表，然后在排序缓冲区中进行排序。
	（5）groupby查询时，同样要建立联合索引，避免使用到临时表
	（6）分页查询时，如果偏移量太大，比如要查询一百万条数据后的十条记录，可以使用主键+子查询的方式，避免进行全表扫描
	（7）使用count函数时直接使用count的话count(*)的效率最高，也可以额外创建一张表去统计不同表中的数据行数，但维护麻烦
	count(*)或count(唯一索引)或count(数字):表中总记录数，count(字段)不会统计null
	(8) 在写update语句时，where条件要添加使用索引，否则会锁会从行锁升级为表锁
	（9）表中数据是否太大，是不是要分库分表
10.为什么要用内连接而不用外连接？
	用外连接的话连接顺序是固定死的，比如left join，他必须先对左表进行全表扫描，然后一条条到右表去匹配；而内连接的话mysql会自己根据查询优化器去判断用哪个表做驱动。
	-
	子查询的话同样也会对驱动表进行全表扫描，所以尽量用小表做驱动表。
11.MySQL整个查询的过程
	1.  客户端先发送查询语句给服务器
	2.  服务器检查缓存，如果存在则返回
	3.  进行sql解析，生成解析树，再预处理，生成第二个解析树，最后再经过优化器，生成真正的执行计划
	4.  根据执行计划，调用存储引擎的API来执行查询
	5.  将结果返回给客户端。
12.执行计划中有哪些字段？
	id select_type ,type,keys,possible_keys,rows,extra,key_len
13.哪些情况索引会失效
	非空判断,前模糊查询,索引列参与计算或类型转换,违背最左匹配原则
14.B和B+数的区别，为什么使用B+数
	B树每个非叶子节点也存储的是直接数据,导致每一行的节点量存储更少,B+树只有叶子节点存储数据,其他非叶子节点存储的是叶子节点的索引地址,达到了每一行更多的索引减少了行数达到减少搜索时间
15.MySQL有哪些锁
	基于属性:共享锁,排他锁,
	基于粒度:行级锁,表级锁,间隙锁
16.Mysql内连接、左连接、右连接的区别
	内连接取量表交集部分，左连接取左表全部右表匹部分，右连接取右表全部坐表匹部分
17.sql执行顺序
	1.  from 
	2.  on 
	3.  join 
	4.  where 
	5.  group by(开始使用select中的别名，后面的语句中都可以使用)
	6.   avg,sum.... 
	7.  having 
	8.  select 
	9.  distinct 
	10.  order by
	11.  limit
18.如何设计数据库？
	（1）抽取实体，如用户信息，商品信息，评论
	-
	（2）分析其中属性，如用户信息：姓名、性别...
	-
	（3）分析表与表之间的关联关系
	-
	然后可以参考第三范式进行设计，设计主键时，主键要尽量小并且定义为自增和不可修改。
19.where和having的区别？
	where是约束声明，having是过滤声明，where早于having执行，并且where不可以使用聚合函数，having可以
20.三大范式
	第一范式:每个列不可拆分
	第二范式第一范式基础上非主键列完全依赖于主键，而不能是依赖于主键的一部分。
	第三范式在第二范式的基础上，非主键列只依赖于主键，不依赖于其他非主键(消除传递依赖)。
21.char和varchar的区别
	char是不可变的，最大长度为255，varchar是可变的字符串，最大长度为2^16
22.InnoDB 什么情况下会产生死锁
	1、互斥条件：一个资源每次只能被一个进程使用；
	2、请求与保持条件：一个进程因请求资源而阻塞时，对已获得的资源保持不放；
	3、不剥夺条件:进程已获得的资源，在末使用完之前，不能强行剥夺；
	4、循环等待条件:若干进程之间形成一种头尾相接的循环等待资源关系；
23.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？
	innodb 引擎：
	MySQL8.0前，下次自增会取表中最大 id + 1。原理是最大id会记录在内存中，重启之后会重新读取表中最大的id
	MySQL8.0后，仍从删除数据 id 后算起。原理是它将最大id记录在redolog里了
	-
	myisam：
	自增的 id 都从删除数据 id 后算起。原理是它将最大id记录到数据文件里了
**五.常用开发框架系列**
1.什么是Spring？
	Spring是一种框架思想
2.IOC是什么？
	翻转控制的编程模式,将new来创建实例的方式变为从容器中通过反射获取实例
3.AOP是什么？ 
	Aspect-Oriented Programming
	将非主要程序或重复程序进行封装,然后通过动态代理方式根据运行的节点在不修改代码的情况下增强代码,提高可用性和扩展性
4.如何定义一个全局异常处理类？
	想要定义一个全局异常处理类的话，我们需要在这个类上添加@ContaollerAdvice注解，然后定义一些用于捕捉不同异常类型的方法，在这些方法上添加@ExceptionHandler(value = 异常类型.class)和@ResponseBody注解，方法参数是HttpServletRequest和异常类型，然后将异常消息进行处理。
	-
	如果我们需要自定义异常的话，就写一个自定义异常类，该类需要继承一个异常接口，类属性包括final类型的连续id、错误码、错误信息，再根据需求写构造方法； 
5.如何使用aop自定义日志？
	
6.循环依赖是什么，怎么解决的？

7.Bean 的作用域

8.Bean 生命周期

9.Spring 事务原理？

10.spring事务失效场景

11.spring事务的隔离级别

12.spring事务的传播行为

12.spring用了哪些设计模式
	单例设计模式,动态代理模式,
14.SpringMV工作原理

15.springboot自动配置原理

16.springboot常用注解
	@SpringBootApplication
	@AutoWrite
	@Bean
	@SpringBootConfiguration
	@Controller
	@Request
17.spring的bean是线程安全的吗？
	不是
六.Redis系列

1.redis为什么快？
	1.完全基于内存的IO
	2.绝大部分情况是单线程(避免竞争和锁定)
		Redis的网络IO和键值对的读写都是由一个线程来完成的，Redis的请求时包括获取（Socket读），解析，执行，内容返回（socket写）等都是由一个顺序串行的主线程处理，这就是所谓的单线程。
		在Redis6.0中新增加了多线程的功能来提高I/O读写性能，他的主要实现思路是将**主线程的IO读写任务拆分给一组独立的线程去执行**，将最耗时的socket读取，请求解析，写入单独外包出去，剩下的命令执行任然是由主线程串行执行和内存的数据交互。
		异步删除或大数据量操作等IO多路复用操作是多线程
	3.高效,简单的数据结构(Hash等O(1)结构)
	4.采用IO多路复用和非阻塞IO
		多路:多个客户端访问
		复用:但进程处理多任务套接字
		原理从**select->poll→epol**阶段
		select是不断遍历访问任务是否完成,最多同时管理1024个
		polll使用pollfd数组来代替select中的bitmap，数组中没有1024的限制,是管理量更大的select
		epoll改进poll,只轮询那些真正发出了事件的流，并且只依次顺序的处理就绪的流,遍历的时候如果未完成则告诉任务完成后执行XX规范操作(减少遍历次数)
2.redis持久化机制
	使用rdb或aof方式实现持久化
	使用bgsave异步同步或save手动同步或系统根据条件触发
3.Redis如何实现key的过期删除？
	默认定期删除+惰性删除  可以根据需求配置删除策略
	定期删除:抽选一定数量的key检查是否过期然后删除
	惰性删除:访问时判断key是否过期,再行删除
4.Redis数据类型
	常用List  String Hash Set  ZSet(SortSet) Pub/Sub
	场景:String缓存json信息
	List可以做消息队列
	Set做去重好友列表
	Zset做排行榜
5.Redis缓存穿透,缓存击穿,缓存雪崩如何解决？
	**缓存穿透**是由于访问不存在的空值造成的永远访问数据库而缓存失效,可以设置对应空值缓存来解决,并设置例如明显无效的条件先做筛选(例如:id<0)->布隆过滤器
	**缓存击穿**是热点数据过期突然大量访问数据库,发现热点数据失效时加互斥锁让只有一个线程访问给足够时间加载到缓存,或者热点数据永不过期
	**缓存雪崩**是由于redis缓存集体过期导致的,可以设置函数来分散峰值时间解决
8.Redis分布式锁的实现原理
	设置setnx+setex让其他服务去访问缓存状态如果为0则代表可以获取锁并将状态改为1
	超时等导致的死锁和可重入性通过Redision解决
9.Redis集群方案
	哨兵模式 1主多从  主负责读写  从只负责读
	集群模式  多集群皆可读写
10.Redis集群主从同步原理
	从节点请求同步,主节点判断是否第一次同步
11.Redis缓存一致性解决方案
	
12.Redis内存淘汰策略
	
**七.计算机网络系列**

1.TCP/IP模型​编辑

 2.浏览器输入地址后做了什么？
	先去本地host查找地址映射然后去DNS服务中查找地址映射,查找到后去请求指定网址的对应端口服务
 3.TCP三次握手

4.为什么TCP不能两次握手

5.TCP四次挥手

6.为什么要进入时间等待状态？

7.TCP 滑动窗口

8.TCP拥塞控制

9.TCP超时重传

10.TCP可靠传输的实现

11.TCP报头有哪些信息

 12.状态码

13.http与https的区别

14.socket通信流程

八.linux系列

1.linux常用命令
	ls 查看当前文件夹下全部文件
	vi 编辑文件
	cd 切换地址
	rm 删除
	
2.linux的io模型

九.其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等...）

1.Java如何实现统计在线人数的功能？
	设置一个count缓存值在redis
2.RabbitMQ如何保证消息不丢失？ 
	重试机制和报错机制
4.设计模式六大原则

5.排序算法的时间复杂度

6.大量数据排名，采用什么数据结构
	SortSet
7.二叉树和堆之间联系或区别

8.hash表冲突的解决方法

9.cookie和session的区别

10.RabbitMQ如何保证消费顺序
	可以设置4条queue为1条达到有序消费
秒杀项目相关问题：

1.项目流程

2.提升qps的操作

微学院相关问题

1.如何用springSecurity做的认证授权？

2.前后端联调经常遇到的问题：

实习中供应链项目的收获

1.熟悉了代码开发规范

 一、Java基础篇
7.ConcurrentHashMap原如何保证的线程安全？
	ConcurrentHashMap的底层数据结构是：Segments数组(分段数组,每段可以自由充当一个数组自行扩容)+HashEntry数组(基于hashcode的数组)+链表
	它采用分段锁保证安全性。容器中有多把锁，每一把锁锁一段数据，这样在多线程访问时不同段的数据时，就不会存在锁竞争了，这样便可以有效地提高并发效率。
	内置ReentrantLock锁,是基于CAS自旋方式的乐观锁,低并发下效率高,特点是可重入性(避免死锁)
10.如何保证ArrayList的线程安全？
	1.主动写包装类,在add()方法和remove(),update()方法调用时加锁
	2.使用Collections帮助类的Collections.synchronizedList()方法
	3.直接使用Vector替代ArrayList,底层原理同ArrayList但是线程安全
13.面向对象和面向过程的区别
		主要区别:
	**1.抽象的对象不同:** 面向过程的编程思想是以过程为中心，将问题分解为一系列的步骤，然后按照一定的顺序依次执行这些步骤。而面向对象的编程思想则是以对象为中心，将问题分解为一些相互协作的对象，每个对象具有自己的属性和方法，通过消息传递的方式进行交互。
	**2.封装性不同:** 面向过程的编程思想强调的是数据和方法的分离，数据和方法是分开定义的。而面向对象的编程思想则强调的是将数据和方法封装在一起，通过接口来控制对数据的访问。
	**3.是否支持继承:** 面向对象的编程思想支持继承，一个类可以继承另一个类的属性和方法，并可以在此基础上进行扩展和修改。而面向过程的编程思想不支持继承，只能通过复制代码来实现类似的功能。
	**4.是否支持多态:** 面向对象的编程思想支持多态，同一个方法可以有不同的实现方式，具体的实现方式取决于调用该方法的对象。而面向过程的编程思想不支持多态，同一个方法只有一种实现方式。
 4.深拷贝和浅拷贝
16.什么是反射？
	反射是一种机制
	通过获取类的class对象然后调用其属性或方法
	要操作权限不够的类属性和方法时、实现自定义注解时、动态加载第三方jar包时、按需加载类，节省编译和初始化时间；  
	获取class对象的方法有：class.forName(类路径)，类.class()，对象的getClass（）
17.Java创建对象的几种方式?
	(1)new关键字   (2)Class.newInstance  反射  (3)Constructor.newInstance
	(4)Clone方法   (5)反序列化
**二.Java多线程篇**
1. 什么是线程上下文切换
	是指当CPU从一个线程中转移到另一个线程时，需要保存当前线程的状态（包括程序计数器、寄存器、栈指针等）并恢复下一个线程的状态，这个过程就是线程上下文切换。
	总结:用线程池来避免频繁创建和销毁线程，或者使用协程等技术来减少线程的切换次数。
 3.什么是死锁

 4.死锁的必要条件
5.Synchrpnized和lock的区别
	Synchronized只能实现非公平锁，而Lock可以实现公平锁和非公平锁
	Synchronized在发生异常时会由JVM自动释放锁，而Lock必须手动释放锁，否则容易出现死锁。
	Synchronized的性能相对较低，因为它会涉及到用户态和内核态的切换，而Lock的性能相对较高，因为它是基于CAS操作实现的。
6.什么是AQS锁?
	:AQS是一种提供了原子式管理同步状态、阻塞和唤醒线程功能以及队列模型的简单框架,是基于底层锁实现的，它是底层锁的一个上层的封装
	AQS的原理是，AQS内部有三个核心组件，一个是state代表加锁状态初始值为0，一个是获取到锁的线程，还有一个阻塞队列。当有线程想获取锁时，会以CAS的形式将state变为1，CAS成功后便将加锁线程设为自己。当其他线程来竞争锁时会判断state是不是0，不是0再判断加锁线程是不是自己，不是的话就把自己放入阻塞队列。这个阻塞队列是用双向链表实现的
	可重入锁的原理就是每次加锁时判断一下加锁线程是不是自己，是的话state+1，释放锁的时候就将state-1。当state减到0的时候就去唤醒阻塞队列的第一个线程。
7.为什么AQS使用的双向链表？
	因为有一些线程可能发生中断 ，而发生中断时候就需要在同步阻塞队列中删除掉，这个时候用双向链表方便删除掉中间的节点
8.有哪些常见的AQS锁
	AQS分为独占锁和共享锁
	ReentrantLock（独占锁）：可重入，可中断，可以是公平锁也可以是非公平锁，非公平锁就是会通过两次CAS去抢占锁，公平锁会按队列顺序排队
	Semaphore（信号量）:设定一个信号量，当调用acquire()时判断是否还有信号，有就获取一个信号量，没有就阻塞等待其他线程释放信号量，当调用release()时释放一个信号量，唤醒阻塞线程。
	应用场景：允许多个线程访问某个临界资源时，如上下车，买卖票
	CountDownLatch（倒计数器）:给计数器设置一个初始值，当调用CountDown()时计数器减一，当调用await() 时判断计数器是否归0，不为0就阻塞，直到计数器为0。
	应用场景：启动一个服务时，主线程需要等待多个组件加载完毕，之后再继续执行
	CyclicBarrier（循环栅栏）:给计数器设置一个目标值,当调用await() 时会计数+1并判断计数器是否达到目标值，未达到就阻塞，直到计数器达到目标值
	应用场景：多线程计算数据，最后合并计算结果的应用场景
10.yield()和join()区别
	yield方法是让其他线程有机会和他竞争
	join方法是让本线程阻塞直到指定线程运行完毕
11.线程池七大参数
	1.  corePoolSize：核心线程数。
	2.  maximumPoolSize：最大线程数。
	3.  keepAliveTime：空闲线程存活时间。
	4.  TimeUnit：时间单位。
	5.  BlockingQueue：线程池任务队列。
	6.  ThreadFactory：创建线程的工厂。
	7.  RejectedExecutionHandler：拒绝策略。（1）抛异常（2）丢弃任务不抛异常（3）打回任务（4）尝试与最老的线程竞争
12.介绍下JMM(Java内存模型 )
	JMM（Java内存模型 ）屏蔽了各种硬件和操作系统的内存访问差异，实现让Java程序在各平台下都能达到一致的内存访问效果，它定义了JVM如何将程序中的变量在主存中读取
	具体定义为：所有变量都存在主存中，主存是线程共享区域；每个线程都有自己独有的工作内存，线程想要操作变量必须从主从中copy变量到自己的工作区，每个线程的工作内存是相互隔离的
	由于主存与工作内存之间有读写延迟，且读写不是原子性操作，所以会有线程安全问题
13.保证并发安全的三大特性？
	 原子性：一次或多次操作在执行期间不被其他线程影响
	可见性：当一个线程在工作内存修改了变量，其他线程能立刻知道
	有序性：JVM对指令的优化会让指令执行顺序改变，有序性是禁止指令重排
 14.volatile
14.单例模式双重校验锁变量为什么使用 volatile 修饰？
	禁止 JVM 指令重排序，new Object()分为三个步骤：为实例对象分配内存，用构造器初始化成员变量，将实例对象引用指向分配的内存；实例对象在分配内存后实才不为null。如果分配内存后还未初始化就先将实例对象指向了内存，那么此时最外层的if会判断实例对象已经不等于null就直接将实例对象返回。而此时初始化还没有完成。
	[详解](https://blog.csdn.net/u010002184/article/details/111876327)
15.有哪些多线程的场景,什么情况下该考虑多线程?
	1.当程序需要同时执行多个任务时,使用多线程并发执行
	2. 当程序需要等待某个操作完成时，可以使用多线程来避免阻塞主线程，从而提高程序的响应速度。
	3. 当程序需要定时执行某个任务时，可以使用多线程来实现定时任务的功能。
	4. 当程序需要处理大量数据时，可以使用多线程来对数据进行分片处理，从而提高程序的处理速度。
16.什么是ThreadLocl,ThreadLocal原理
	ThreadLocl是java中的一个类作用是提供给多线程一个局部变量
	原理是每个线程复制一份变量的副本,不同线程之间不可见，保证线程安全

17.什么是CAS锁

18.Synchronized锁原理和优化

19.如何根据 CPU 核心数设计线程池线程数量

三.JVM篇

1.JVM运行时数据区（内存结构）

2.什么情况下会内存溢出？

3.JVM有哪些垃圾回收算法？

4.GC如何判断对象可以被回收？

5.典型垃圾回收器

6.类加载器和双亲委派机制

7.JVM中有哪些引用？

8.类加载过程

9.JVM类初始化顺序

10..对象的创建过程

11.对象头中有哪些信息

12.JVM内存参数

13.GC的回收机制和原理

四.Mysql篇

1.MyIsAm和InnoDB的区别

2.mysql事务特性

3.事务靠什么保证

4.事务的隔离级别

5.什么是快照读和当前读

6.MVCC是什么

7.MySQL有哪些索引

8.聚簇索引和非聚簇索引的区别

9.MySQL如何做慢SQL优化

10.为什么要用内连接而不用外连接？

11.MySQL整个查询的过程

12.执行计划中有哪些字段？

13.哪些情况索引会失效

14.B和B+数的区别，为什么使用B+数

15.MySQL有哪些锁

16.Mysql内连接、左连接、右连接的区别

17.sql执行顺序

18.如何设计数据库？

19.where和having的区别？

20.三大范式

21.char和varchar的区别

22.InnoDB 什么情况下会产生死锁

23.MySQL 删除自增 id，随后重启 MySQL 服务，再插入数据，自增 id 会从几开始？

五.常用开发框架系列

1.什么是Spring？

2.IOC是什么？

3.AOP是什么？ 

4.如何定义一个全局异常处理类？

5.如何使用aop自定义日志？

6.循环依赖是什么，怎么解决的？

7.Bean 的作用域

8.Bean 生命周期

9.Spring 事务原理？

10.spring事务失效场景

11.spring事务的隔离级别

12.spring事务的传播行为

13.Spring IoC

12.spring用了哪些设计模式

14.SpringMV工作原理

15.springboot自动配置原理

16.springboot常用注解

17.spring的bean是线程安全的吗？

六.Redis系列

1.redis为什么快？

2.redis持久化机制

3.Redis如何实现key的过期删除？

4.Redis数据类型

5.Redis缓存穿透如何解决？

6.Redis如何解决缓存击穿？

7.Redis如何解决缓存雪崩？

8.Redis分布式锁的实现原理

9.Redis集群方案

10.Redis集群主从同步原理

11.Redis缓存一致性解决方案

12.Redis内存淘汰策略

七.计算机网络系列

1.TCP/IP模型​编辑

 2.浏览器输入地址后做了什么？

 3.TCP三次握手

4.为什么TCP不能两次握手

5.TCP四次挥手

6.为什么要进入时间等待状态？

7.TCP 滑动窗口

8.TCP拥塞控制

9.TCP超时重传

10.TCP可靠传输的实现

11.TCP报头有哪些信息

 12.状态码

13.http与https的区别

14.socket通信流程

八.linux系列

1.linux常用命令

2.linux的io模型

九.其他（RabitMQ、数据结构与算法、nginx、git、jwt登录等...）

1.Java如何实现统计在线人数的功能？

2.RabbitMQ如何保证消息不丢失？ 

4.设计模式六大原则

5.排序算法的时间复杂度

6.大量数据排名，采用什么数据结构

7.二叉树和堆之间联系或区别

8.hash表冲突的解决方法

9.cookie和session的区别

10.RabbitMQ如何保证消费顺序

秒杀项目相关问题：

1.项目流程

2.提升qps的操作

微学院相关问题

1.如何用springSecurity做的认证授权？

2.前后端联调经常遇到的问题：

实习中供应链项目的收获

1.熟悉了代码开发规范

![[常用查找算法_image_1.png]]

**二分查找法:**
	**原理:**
	队头min和队尾max队中avg(max+min)/2,通过找avg比较需要找的数的大小往一侧偏移后再找avg比对,以此类推
	**使用条件**: 1.必须采用顺序存储结构 2.必须按关键字大小有序排列
	**运行时间:** O(㏒₂n)
**kmp算法:**
	是一种文字匹配算法
	[视屏详解](https://www.youtube.com/watch?v=af1oqpnH1vA)
	**原理:**  **生成一个"模式串"辅助匹配跳过多格,从而减少穷举的时间**
	**时间复杂度**为O(n+m)，其中n为文本串的长度，m为模式串的长度
	**代码实现**:
		//代码4-1    
		//修正后的求next数组各值的函数代码    
		void get_nextval(char const* ptrn, int plen, int* nextval)    
		{    
		    int i = 0;  //注，此处与下文的代码实现二不同的是，i是从0开始的（代码实现二i从1开始）     
		    nextval[i] = -1;    
		    int j = -1;    
		    while( i < plen-1 )    
		    {    
		        if( j == -1 || ptrn[i] == ptrn[j] )   //循环的if部分    
		        {    
		            ++i;    
		            ++j;    
		            //修正的地方就发生下面这4行    
		            if( ptrn[i] != ptrn[j] ) //++i，++j之后，再次判断ptrn[i]与ptrn[j]的关系    
		                nextval[i] = j;      //之前的错误解法就在于整个判断只有这一句。    
		            else    
		                nextval[i] = nextval[j];    
		        }    
		        else                                 //循环的else部分    
		            j = nextval[j];    
		    }    
		}    
		  
		void print_progress(char const* src, int src_index, char const* pstr, int pstr_index)  
		{  
		    cout<<src_index<<"\t"<<src<<endl;  
		    cout<<pstr_index<<"\t";  
		    for( int i = 0; i < src_index-pstr_index; ++i )  
		        cout<<" ";  
		    cout<<pstr<<endl;  
		    cout<<endl;  
		}  
		  
		//代码5-1    
		//int kmp_seach(char const*, int, char const*, int, int const*, int pos)  KMP模式匹配函数    
		//输入：src, slen主串    
		//输入：patn, plen模式串    
		//输入：nextval KMP算法中的next函数值数组    
		int kmp_search(char const* src, int slen, char const* patn, int plen, int const* nextval, int pos)    
		{    
		    int i = pos;    
		    int j = 0;    
		    while ( i < slen && j < plen )    
		    {    
		        if( j == -1 || src[i] == patn[j] )    
		        {    
		            ++i;    
		            ++j;    
		        }    
		        else    
		        {    
		            j = nextval[j];              
		            //当匹配失败的时候直接用p[j_next]与s[i]比较，    
		            //下面阐述怎么求这个值，即匹配失效后下一次匹配的位置    
		        }    
		    }    
		    if( j >= plen )    
		        return i-plen;    
		    else    
		        return -1;    
		}    
		  
		int   main()  
		{  
		    std::string src = "aabcabcebafabcabceabcaefabcacdabcab";  
		    std::string prn = "abac";  
		  
		    int* nextval = new int[prn.size()];  
		    //int* next = new int[prn.size()];  
		    get_nextval(prn.data(), prn.size(), nextval);  
		    //get_next(prn.data(), prn.size(), next);  
		  
		    for( int i = 0; i < prn.size(); ++i )  
		        cout<<nextval[i]<<"\t";  
		    cout<<endl;  
		      
		    cout<<"result sub str: "<<src.substr( kmp_search(src.data(), src.size(), prn.data(), prn.size(), nextval, 0) )<<endl;  
		    system("pause");  
		  
		    delete[] nextval;  
		    return 0;  
		}  
分治算法:

动态规划算法:

朴素贝叶斯算法（Naive Bayesian algorithm):

暴力匹配:















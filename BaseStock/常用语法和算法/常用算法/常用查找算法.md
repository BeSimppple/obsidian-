![[常用查找算法_image_1.png]]

**二分查找法:**
	**原理:**
	队头min和队尾max队中avg(max+min)/2,通过找avg比较需要找的数的大小往一侧偏移后再找avg比对,以此类推
	**使用条件**: 1.必须采用顺序存储结构 2.必须按关键字大小有序排列
	**运行时间:** O(㏒₂n)
**kmp算法:**
	是一种文字匹配算法
	[视屏详解](https://www.youtube.com/watch?v=af1oqpnH1vA)
	**原理:**  **生成一个"模式串"辅助匹配跳过多格,从而减少穷举的时间**
	**时间复杂度**为O(n+m)，其中n为文本串的长度，m为模式串的长度
	**代码实现**:
		public static int kmp(String s, String p) {  
		    int m = s.length(), n = p.length();  
		    if (n == 0) {  
		        return 0;  
		    }  
		    int[] next = getNext(p);  
		    int i = 0, j = 0;  
		    while (i < m && j < n) {  
		        if (j == -1 || s.charAt(i) == p.charAt(j)) {  
		            i++;  
		            j++;  
		        } else {  
		            j = next[j];  
		        }  
		    }  
		    if (j == n) {  
		        return i - j;  
		    } else {  
		        return -1;  
		    }  
		}  
		  
		private static int[] getNext(String p) {  
		    int n = p.length();  
		    int[] next = new int[n];  
		    next[0] = -1;  
		    int i = 0, j = -1;  
		    while (i < n - 1) {  
		        if (j == -1 || p.charAt(i) == p.charAt(j)) {  
		            i++;  
		            j++;  
		            next[i] = j;  
		        } else {  
		            j = next[j];  
		        }  
		    }  
		    return next;  
		}
分治算法:

动态规划算法:
	将问题分解成小问题,**通过解决小问题并记忆的方式来减少算法时间**
	-
	动态规划相当于递归的改进版，就是用辅助数组记录求解的中间过程来减少计算量。 需要一个长度为N的辅助数组记录当前子串的最长递增子序列的长度。 平均时间复杂度为NlogN，空间复杂度为N
朴素贝叶斯算法（Naive Bayesian algorithm):

暴力匹配(回溯算法):

**算法的5个基本特征：**
	1. 确定性
	2. 有穷性
	3. 输入
	4. 输出
	5. 可行性













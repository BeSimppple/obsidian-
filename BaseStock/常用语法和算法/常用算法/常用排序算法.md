[排序算法动画图解及理论详解](https://blog.csdn.net/pange1991/article/details/85460755)
![[常用排序算法_image_1.png]]
最常用排序算法:
	使用情况最广且时间复杂度较低的排序算法是 **快速排序**。快速排序的时间复杂度为 O(nlogn)，在大多数情况下比其他常用的排序算法更快。
	-
	快速排序的基本思想是选择一个基准元素，将序列分成两个子序列，小于基准元素的放在左边，大于基准元素的放在右边，然后对左右两个子序列递归地进行快速排序。其实现过程如下：
	1.  选择一个基准元素，将序列分成两个子序列。
	2.  对左右两个子序列递归地进行快速排序。
	3.  合并左右两个子序列。
	快速排序的优点是实现简单、速度快、效率高，缺点是对于近乎有序的序列，时间复杂度会退化为 O(n^2)

**冒泡排序**
	![[常用排序算法_image_2.gif]]

**直接选择排序**
	![[常用排序算法_image_3.gif]]

**直接插入排序**
	![[常用排序算法_image_4.gif]]

**快速排序:**
	**概念:** 快速排序从小到大排序：**在数组中随机选一个数（默认数组首个元素），数组中小于等于此数的放在左边部分，大于此数的放在右边部分**，这个操作确保了这个数是处于正确位置的，再对左边部分数组和右边部分数组递归调用快速排序，重复这个过程
	![[常用排序算法_image_5.gif]]
	![[常用排序算法_image_6.gif]]
	**代码:**:

```
void quicksort(int a[], int left, int right) {   
int i, j, t, pivotkey;    
if (left > right)   //（递归过程先写结束条件）        
return;     
pivotkey = a[left]; //temp中存的就是基准数（枢轴）   
i = left;    j = right;   
while (i < j) {        //顺序很重要，要先从右边开始找（最后交换基准时换过去的数要保证比基准小，因为基准选取数组第一个数）       
while (a[j] >= pivotkey && i < j) {         
j--;       
}       
a[i] = a[j];        //再找左边的     
while (a[i] <= pivotkey && i < j) {     
i++;        
}     
a[j] = a[i];   
}    //最终将基准数归位 
a[i] = pivotkey;    
quicksort(a, left, i - 1);//继续处理左边的，这里是一个递归的过程   
quicksort(a, i + 1, right);//继续处理右边的 ，这里是一个递归的过程
}
```

## 5 堆排序
**堆排序**
	![[常用排序算法_image_7.gif]]
	![[常用排序算法_image_8.gif]]

**希尔排序**
	![[常用排序算法_image_9.gif]]

**归并排序**
	![[常用排序算法_image_10.gif]]

---
堆和二叉树的区别?
	以小根堆为例，堆的特点是上级结点的数必然小于等于子结点的数，而两个子结点的关键字没有次序规定，
	-
	而二叉排序数中，每个上级结点的数均大于左侧子树结点的数，均小于右子树结点的数，也就是说，每个上级结点的左右孩子的关键字有次序关系，
	-
	这样，当对两种树执行中序遍历后，二叉树会得到一个有序的序列，而堆不一定。
	![[常用排序算法_image_11.png]]
什么是平衡二叉树?
	结论:任何一个结点的左子树与右子树都是平衡二叉树，并且高度之差的绝对值不超过 1。
平衡二叉树如何调整:
	为两种情况：左旋和右旋。左旋是指将某个节点的右子树作为新的子树，右旋是指将某个节点的左子树作为新的子树。这两种调整操作可以使树重新平衡。
	-
	左旋和右旋的具体实现方法如下：
	-
	左旋：假设当前节点为A，A的右子树为B，B的左子树为C。左旋操作将B作为新的根节点，A作为B的左子树，C作为A的右子树。
	-
	右旋：假设当前节点为A，A的左子树为B，B的右子树为C。右旋操作将B作为新的根节点，A作为B的右子树，C作为A的左子树。







#正则表达式
概念:正则表达式通常被用来检索,替换那些符合某个模式的文本
常用方法:
1.test():通过模式来搜索字符串，然后根据结果返回 true 或 false
2.exec():它通过指定的模式搜索字符串，并返回已找到的文本,不匹配返回 null

| 字符表示 | 字符含义 |
| ----------- | ----------------------------------- |
| [abc] | 匹配a或者b或者c(数量为1个) |
| [a-z] | 匹配任意小写字母(数量为1个) |
| [a-zA-Z0-9] | 匹配任意字母数字(数量为1个)
| \d | 匹配任意数字(数量为1个),等价于[0-9] |
| .(点) | 匹配除\r \n以外的任何单个字符 |
数量表示
| 字符表示 | 字符含义 |
| -------- | ---------------------------------- |
| {n} | 匹配前面字符数量个数为n个 |
| {n,} | 匹配前面字符数量最少n个 |
| {m,n} | 匹配前面字符数量个数为m个到n个之间 |
| * | 匹配前面的子表达式任意次(包含0次) |

开头结尾
| 字符表示 | 字符含义 |
| -------- | ------------------------- |
| ^ | 以什么开头 |
| $ | 以什么结尾 |
| [^abc] | 匹配除了abc以外的任意字符 |

  ![[正则表达式_image_1.png]]

正则表达式特点`:

1. 问号既可以匹配字符数量0次或1次，也可以表示非贪婪匹配

2. 问号加在 *,+,?，{n}，{n,}，{n,m} 后面时，匹配模式是非贪婪的。非贪婪模式尽可能少地匹配所搜索的字符串，而默认的贪婪模式则尽可能多地匹配所搜索的字符串

  

js表单效验 required="required" 标签内容为必填项

是指一个用来描述或者匹配一系列符合某个语法规则的字符串的单个字符串。其实就是一种规则。有自己特殊的应用。

例:

System.out.println(

qqStr.matches("[1-9]{1}[0-9]{4.14}")? "YEAH" : "NO");

//第一位数字1-9,后面有4到14位的数字,每个都是0-9.

字符类

[abc] a、b 或 c（简单类）

[^abc] 任何字符，除了 a、b 或 c（否定）

[a-zA-Z] a到 z 或 A到 Z，两头的字母包括在内（范围）

[0-9] 0到9的字符都包括

注意事项:

如果没有规定长度，那么默认长度是1.

  

预定义字符类

. 任何字符。

\d 数字：[0-9]

\D 非数字:[^0-9]

\w 单词字符：[a-zA-Z_0-9]

\W 非单词字符:[^\w]

\s 空白字符:[ \t\n\x0B\f\r]

\S 非空白字符:[^\s]

  

数量词

A:Greedy 数量词

X? :X，一次或一次也没有

X*:X，零次到多次

X+ :X，一次到 多次

X{n} :X，恰好 n 次

X{n,} :X，至少 n 次

X{n,m} :X，至少 n 次，但是不超过 m 次

  

正则表达式的分割功能

public String[] split(String regex)

  

Pattern和Matcher的概述

//1.获取正则表达式对象

Pattern pattern = Pattern.compile("a{1,5}");

//2.获得匹配对象

Matcher matcher = pattern.matcher("aaaaa");

//3.开始匹配

boolean flag = matcher.matches();

System.out.println(flag);

  

正则表达式的获取功能

例如

//写入要找的对象的正则表达式

Pattern pattern =Pattern.compile(reg);

//同正则表达式匹配要找的内容

Matcher matcher = pattern.matcher(msg);

  

while(matcher.find()){

//其实matcher.find返回的也是boolean值,所以可以替换

String phone = matcher.group();

System.out.println(phone);